<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content=" 💡 本文记录 Go 语言学习过程中的核心概念和最佳实践，涵盖并发编程、数据结构、指针操作等关键知识点。\n引用类型 通道(channel)、 映射(map)、 切片(slice)\n"><title>Go语言实战笔记</title>
<link rel=canonical href=https://heyuuuu77.github.io/posts/go/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Go语言实战笔记"><meta property='og:description' content=" 💡 本文记录 Go 语言学习过程中的核心概念和最佳实践，涵盖并发编程、数据结构、指针操作等关键知识点。\n引用类型 通道(channel)、 映射(map)、 切片(slice)\n"><meta property='og:url' content='https://heyuuuu77.github.io/posts/go/'><meta property='og:site_name' content='Heyuuuu'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2025-02-13T10:20:34+08:00'><meta property='article:modified_time' content='2025-02-13T10:20:34+08:00'><meta name=twitter:title content="Go语言实战笔记"><meta name=twitter:description content=" 💡 本文记录 Go 语言学习过程中的核心概念和最佳实践，涵盖并发编程、数据结构、指针操作等关键知识点。\n引用类型 通道(channel)、 映射(map)、 切片(slice)\n"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_f509edb42ecc0ebd.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>👋</span></figure><div class=site-meta><h1 class=site-name><a href=/>Heyuuuu</a></h1><h2 class=site-description>简单记录生活点滴，分享技术学习心得</h2></div></header><ol class=menu-social><li><a href=https://github.com/heyuuuu77 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>首页</span></a></li><li><a href=/posts/><span>文章</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>分类</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>标签</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#引用类型>引用类型</a></li><li><a href=#sync-包>sync 包</a><ol><li><a href=#命名规范>命名规范</a></li></ol></li><li><a href=#最佳实践>最佳实践</a><ol><li><a href=#接收者类型选择>接收者类型选择</a></li><li><a href=#接口类型的方法调用规则>接口类型的方法调用规则</a></li></ol></li><li><a href=#go-命令>GO 命令</a><ol><li><a href=#go-vet>go vet</a></li><li><a href=#go-fmt>go fmt</a></li><li><a href=#go-doc>go doc</a></li></ol></li><li><a href=#数组切片映射>数组、切片、映射</a></li><li><a href=#指针>指针</a></li><li><a href=#channel>Channel</a><ol><li><a href=#无缓冲通道>无缓冲通道</a></li><li><a href=#使用-channel-监控协程完成>使用 Channel 监控协程完成</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/go/>Go语言实战笔记</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025-02-13</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 5 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>💡 本文记录 Go 语言学习过程中的核心概念和最佳实践，涵盖并发编程、数据结构、指针操作等关键知识点。</p></blockquote><h2 id=引用类型>引用类型</h2><p>通道(channel)、 映射(map)、 切片(slice)</p><blockquote><p>⚠️ <strong>提示</strong>：引用类型在传递时传递的是引用，修改会影响原始数据。</p></blockquote><h2 id=sync-包>sync 包</h2><p>sync 包提供同步 goroutine 的功能。 在Go语言中， main终止则代表了程序终止， main函数终止前还会关闭所有之前启动且运行的 goroutine。
并发写程序时，最佳做法是 在main函数返回前，清理并终止所有之前启动的 goroutine。编写启动和终止都清晰的程序，减少bug，防止资源异常。</p><p>sync 包的 WaitGroup 会跟踪所有启动的 goroutine。 WaitGroup 是一个计数信号量，用来统计每个 goroutine 是否完成了工作。
具体做法是: 将 WaitGroup 的变量值设置为要启动的 goroutine 数量。 每个 goroutine 完成工作后， 递减 WaitGroup 变量的计数值。
当这个值为0，就知道所有的 goroutine 都完成了工作。</p><blockquote><p>💡 <strong>最佳实践</strong>：使用 <code>defer wg.Done()</code> 确保 goroutine 完成时一定会调用 Done，避免程序永久阻塞。</p></blockquote><h3 id=命名规范>命名规范</h3><ol><li>命名接口时，如果接口内就一个方法，需要以 er 结尾。 如 Matcher。 如果接口类型内部声明了多个方法，其名字需要与其行为关联</li></ol><h2 id=最佳实践>最佳实践</h2><h3 id=接收者类型选择>接收者类型选择</h3><p>如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者类型绑定在一起。
值类型和引用类型作为接收者的方法，在调用时编译器会自动编码/解码对应的类型，然后传递给方法。例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=c1>// 方法声明为使用 defaultMatcher 类型的值作为接收者</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>defaultMatch</span><span class=p>)</span> <span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span> <span class=o>*</span><span class=nx>Feed</span><span class=p>,</span> <span class=nx>stringTerm</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 声明一个指向 defaultMatcher类型值的指针</span>
</span></span><span class=line><span class=cl><span class=nx>dm</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>defaultMatch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 编译器会解开dm指针的引用，使用对应的值调用方法</span>
</span></span><span class=line><span class=cl><span class=nx>dm</span><span class=p>.</span><span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span><span class=p>,</span> <span class=s>&#34;test&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 方法声明为使用指向defaultMatcher类型值的指针作为接收者</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>defaultMatcher</span><span class=p>)</span> <span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span> <span class=o>*</span><span class=nx>Feed</span><span class=p>,</span> <span class=nx>searchTerm</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 声明一个defaultMatcher类型的值</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>dm</span> <span class=nx>defaultMatch</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 编译器会自动生成指针引用dm值，使用指针调用方法</span>
</span></span><span class=line><span class=cl><span class=nx>dm</span><span class=p>.</span><span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span><span class=p>,</span> <span class=s>&#34;test&#34;</span><span class=p>)</span><span class=err>”</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=接口类型的方法调用规则>接口类型的方法调用规则</h3><p>与直接通过值或者指针调用不同， 如果通过接口类型的值调用方法，规则有很大不同。</p><ol><li>使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。</li><li>使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。</li></ol><blockquote><p>⚠️ <strong>重要</strong>：接口调用与直接调用规则不同！指针接收者的方法只能通过指针调用接口。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=c1>// 方法声明为使用指向defaultMatcher类型值的指针作为接收者</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>defaultMatcher</span><span class=p>)</span> <span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span> <span class=o>*</span><span class=nx>Feed</span><span class=p>,</span> <span class=nx>searchTerm</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过interface类型的值来调用方法</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>dm</span> <span class=nx>defaultMatcher</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>matcher</span> <span class=nx>Matcher</span> <span class=p>=</span> <span class=nx>dm</span>     <span class=c1>// 将值赋值给接口类型</span>
</span></span><span class=line><span class=cl><span class=nx>matcher</span><span class=p>.</span><span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span><span class=p>,</span> <span class=s>&#34;test&#34;</span><span class=p>)</span> <span class=c1>// 使用值来调用接口方法</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&gt;</span> <span class=k>go</span> <span class=nx>build</span>
</span></span><span class=line><span class=cl><span class=nx>cannot</span> <span class=nx>use</span> <span class=nf>dm</span> <span class=p>(</span><span class=kd>type</span> <span class=nx>defaultMatcher</span><span class=p>)</span> <span class=nx>as</span> <span class=kd>type</span> <span class=nx>Matcher</span> <span class=nx>in</span> <span class=nx>assignment</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 方法声明为使用defaultMatcher类型的值作为接收者</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>defaultMatcher</span><span class=p>)</span> <span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span> <span class=o>*</span><span class=nx>Feed</span><span class=p>,</span> <span class=nx>searchTerm</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过interface类型的值来调用方法</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>dm</span> <span class=nx>defaultMatcher</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>matcher</span> <span class=nx>Matcher</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>dm</span>    <span class=c1>// 将指针赋值给接口类型</span>
</span></span><span class=line><span class=cl><span class=nx>matcher</span><span class=p>.</span><span class=nf>Search</span><span class=p>(</span><span class=nx>feed</span><span class=p>,</span> <span class=s>&#34;test&#34;</span><span class=p>)</span> <span class=c1>// 使用指针来调用接口方法</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&gt;</span> <span class=k>go</span> <span class=nx>build</span>
</span></span><span class=line><span class=cl><span class=nx>Build</span> <span class=nx>Successful</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=go-命令>GO 命令</h2><h3 id=go-vet>go vet</h3><p>可以帮助检测代码的常见错误。 例如： Printf类函数调用时，类型匹配错误参数、错误的结构题标签、没有指定字段名的结构字面量</p><h3 id=go-fmt>go fmt</h3><p>fmt 工具会将开发人员的代码布局成和go源代码类似的风格。 But,现代IDE在保存代码时会自动格式化。使用 vim 编程建议使用。</p><h3 id=go-doc>go doc</h3><p>有两种方式，一直是直接在命令行获取文档. 比如直接查看 <code>archive/tar</code>包的相关文档，在命令行中执行: <code>go doc tar</code>。
另一种：在Terminal中输入<code>godoc -http=:6060</code> 可以直接生成浏览器文档。查看更多细节。 需要注意的是: godoc 不再包含在 Go 的标准工具链中，需要手动安装</p><p>手动安装 godoc（适用于 Go 1.16 及以上版本）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go install golang.org/x/tools/cmd/godoc@latest
</span></span></code></pre></td></tr></table></div></div><blockquote><p>💡 <strong>提示</strong>：在保存代码前运行 <code>go vet</code> 和 <code>go fmt</code> 可以避免很多常见错误。大多数 IDE 都支持自动运行这些工具。</p></blockquote><h2 id=数组切片映射>数组、切片、映射</h2><p>数组是切片和映射的基础数据结构</p><p>在Go语言中，数组是一个长度固定的数据类型，用于存储一段具有相同类型的元素的连续块。 数组存储的类型可以是内置类型，如整数或者字符串，也可以是某种结构类型。数组声明完之后，数据类型和数组长度就不能改变了</p><blockquote><p>📝 <strong>注意</strong>：数组是值类型，切片和映射是引用类型。使用切片比数组更灵活，推荐优先使用切片。</p></blockquote><h2 id=指针>指针</h2><p>golang中是值传递。 传址也是传递地址的副本。</p><ul><li><code>&</code> 是地址运算符，它位于值类型之前，返回存储改值的内存位置的地址</li><li><code>*</code> 是间接寻址运算符。位于指针变量之前，返回指向的值</li></ul><blockquote><p>⚠️ <strong>记住</strong>：Go 中一切都是值传递。即使传递指针，传递的也是指针的副本，只不过它们指向同一块内存。</p></blockquote><h2 id=channel>Channel</h2><p>在Golang中， channel分有缓存通道和无缓冲通道。</p><h3 id=无缓冲通道>无缓冲通道</h3><p>无缓冲通道：在写入channel后，就会阻塞等待接受者读取。Go中有大量依赖阻塞特性的场景，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=c1>// 示例： 创建一个生成器</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>generateInteger</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>cnt</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>cnt</span>
</span></span><span class=line><span class=cl>            <span class=nx>cnt</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>generate</span> <span class=o>:=</span> <span class=nf>generateInteger</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>generate</span><span class=p>())</span> <span class=c1>// 0</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>generate</span><span class=p>())</span> <span class=c1>// 1</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>generate</span><span class=p>())</span> <span class=c1>//</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>💡 <strong>核心理解</strong>：我一开始有个疑问，在初始化generateInteger()之后，for循环一直在执行中，不会导致超时或者OOM么。但事实上是，循环中的操作会被 channel 的阻塞特性"限流"，不会无限制占用内存。</p></blockquote><h3 id=使用-channel-监控协程完成>使用 Channel 监控协程完成</h3><p>并且很多Go程序都会用到这个特性。下面是通过channel监控子协程的完成。不用通过time.Sleep等不可靠的方式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>task</span><span class=p>(</span><span class=nx>done</span> <span class=kd>chan</span><span class=o>&lt;-</span><span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里执行子任务</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=c1>//任务完成，发送信号</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>task</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span><span class=nx>done</span>  <span class=c1>// 这里就会阻塞等待协程完成任务</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;任务完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>✅ <strong>最佳实践</strong>：使用空结构体 <code>struct{}{}</code> 作为信号传递，因为它不占用内存空间。使用单向 channel (`chan<-` 或 `<-chan`) 可以提高类型安全性。</p></blockquote><hr><blockquote><p>📚 <strong>参考资源</strong></p><ul><li>《Go语言实战》</li><li>Go 官方文档：https://go.dev/doc/</li></ul></blockquote></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 © 2024-2025 Heyuuuu</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>