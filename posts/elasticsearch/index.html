<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Elasticsearch | heyuuuu77</title>
<meta name=keywords content><meta name=description content='start elasticsearch with docker localhost
æ‰§è¡Œ
curl -fsSL https://elastic.co/start-local | sh 8DkwaOdk 8DkwaOdk elastic
curl -ssSL will get start-local.sh. The content will be:

#!/bin/sh
# --------------------------------------------------------
# Run Elasticsearch and Kibana for local testing
# Note: do not use this script in a production environment
# --------------------------------------------------------
#
# Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
# or more contributor license agreements. See the NOTICE file distributed with
# this work for additional information regarding copyright
# ownership. Elasticsearch B.V. licenses this file to you under
# the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
set -eu

parse_args() {
  # Parse the script parameters
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -v)
        # Check that there is another argument for the version
        if [ $# -lt 2 ]; then
          echo "Error: -v requires a version value (eg. -v 8.17.0)"
          exit 1
        fi
        es_version="$2"
        shift 2
        ;;

      --esonly)
        esonly=true
        shift
        ;;

      --)
        # End of options; shift and exit the loop
        shift
        break
        ;;

      -*)
        # Unknown or unsupported option
        echo "Error: Unknown option &#39;$1&#39;"
        exit 1
        ;;

      *)
        # We&#39;ve hit a non-option argument; stop parsing options
        break
        ;;
    esac
  done
}

startup() {
  echo
  echo &#39;  ______ _           _   _      &#39;
  echo &#39; |  ____| |         | | (_)     &#39;
  echo &#39; | |__  | | __ _ ___| |_ _  ___ &#39;
  echo &#39; |  __| | |/ _` / __| __| |/ __|&#39;
  echo &#39; | |____| | (_| \__ \ |_| | (__ &#39;
  echo &#39; |______|_|\__,_|___/\__|_|\___|&#39;
  echo &#39;-------------------------------------------------&#39;
  echo &#39;ðŸš€ Run Elasticsearch and Kibana for local testing&#39;
  echo &#39;-------------------------------------------------&#39;
  echo 
  echo &#39;â„¹ï¸  Do not use this script in a production environment&#39;
  echo

  # Version
  version="0.10.0"

  # Folder name for the installation
  installation_folder="${ES_LOCAL_DIR:-elastic-start-local}"
  # API key name for Elasticsearch
  api_key_name="elastic-start-local"
  # Name of the error log
  error_log="error-start-local.log"
  # Minimum version for docker-compose
  min_docker_compose="1.29.0"
  # Elasticsearch container name
  elasticsearch_container_name="es-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}"
  # Kibana container name
  kibana_container_name="kibana-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}"
  # Kibana settings container name
  kibana_settings_container_name="kibana-local-settings${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}"
  # Minimum disk space required for docker images + services (in GB)
  min_disk_space_required=5
}

# Check for ARM64 architecture
is_arm64() {
  arch="$(uname -m)"
  if [ "$arch" = "arm64" ] || [ "$arch" = "aarch64" ]; then
    return 0 # Return 0 (true)
  else
    return 1 # Return 1 (false)
  fi
}

# Alternative to sort -V, which is not available in BSD-based systems (e.g., macOS)
version_sort() {
  awk -F&#39;.&#39; &#39;
  {
      printf("%d %d %d %s\n", $1, $2, $3, $0)
  }&#39; | sort -n -k1,1 -k2,2 -k3,3 | awk &#39;{print $4}&#39;
}

# Function to check if the format is a valid semantic version (major.minor.patch)
is_valid_version() {
  echo "$1" | grep -E -q &#39;^[0-9]+\.[0-9]+\.[0-9]+$&#39;
}

# Get the latest stable version of Elasticsearch
# Note: It removes all the beta or candidate releases from the list
# but includes the GA releases (e.g. new major)
get_latest_version() {
  versions="$(curl -s "https://artifacts.elastic.co/releases/stack.json")"
  latest_version=$(echo "$versions" | awk -F&#39;"&#39; &#39;/"version": *"/ {print $4}&#39; | grep -E &#39;^[0-9]+\.[0-9]+\.[0-9]+( GA)?$&#39; | version_sort | tail -n 1)
  # Remove the GA prefix from the version, if present
  latest_version=$(echo "$latest_version" | awk &#39;{ gsub(/ GA$/, "", $0); print }&#39;)

  # Check if the latest version is empty
  if [ -z "$latest_version" ]; then
    echo "Error: the latest Elasticsearch version is empty"
    exit 1
  fi
  # Check if the latest version is valid
  if ! is_valid_version "$latest_version"; then
    echo "Error: {$latest_version} is not a valid Elasticsearch stable version"
    exit 1
  fi

  echo "$latest_version"
}

# Detect if running on LXC container
detect_lxc() {
    # Check /proc/1/environ for LXC container identifier
    if grep -qa "container=lxc" /proc/1/environ 2>/dev/null; then
      return 0
    fi
    # Check /proc/self/cgroup for LXC references
    if grep -q "lxc" /proc/self/cgroup 2>/dev/null; then
      return 0
    fi
    # Check for LXC in /sys/fs/cgroup
    if grep -q "lxc" /sys/fs/cgroup/* 2>/dev/null; then  
      return 0
    fi
    # Use systemd-detect-virt if available
    if command -v systemd-detect-virt >/dev/null 2>&amp;1; then
      if [ "$(systemd-detect-virt)" = "lxc" ]; then
        return 0
      fi
    fi
    return 1
}

# Get linux distribution
get_os_info() {
  if [ -f /etc/os-release ]; then
      # Most modern Linux distributions have this file
      . /etc/os-release
      echo "Distribution: $NAME"
      echo "Version: $VERSION"
  elif [ -f /etc/lsb-release ]; then
      # For older distributions using LSB (Linux Standard Base)
      . /etc/lsb-release
      echo "Distribution: $DISTRIB_ID"
      echo "Version: $DISTRIB_RELEASE"
  elif [ -f /etc/debian_version ]; then
      # For Debian-based distributions without os-release or lsb-release
      echo "Distribution: Debian"
      echo "Version: $(cat /etc/debian_version)"
  elif [ -f /etc/redhat-release ]; then
      # For Red Hat-based distributions
      echo "Distribution: $(cat /etc/redhat-release)"
  elif [ -n "${OSTYPE+x}" ]; then
    if [ "${OSTYPE#darwin}" != "$OSTYPE" ]; then
        # macOS detection
        echo "Distribution: macOS"
        echo "Version: $(sw_vers -productVersion)"
    elif [ "$OSTYPE" = "cygwin" ] || [ "$OSTYPE" = "msys" ] || [ "$OSTYPE" = "win32" ]; then
        # Windows detection in environments like Git Bash, Cygwin, or MinGW
        echo "Distribution: Windows"
        echo "Version: $(cmd.exe /c ver | tr -d &#39;\r&#39;)"
    elif [ "$OSTYPE" = "linux-gnu" ] && uname -r | grep -q "Microsoft"; then
        # Windows Subsystem for Linux (WSL) detection
        echo "Distribution: Windows (WSL)"
        echo "Version: $(uname -r)"
    fi
  else
      echo "Unknown operating system"
  fi
  if [ -f /proc/version ]; then
    # Check if running on WSL2 or WSL1 for Microsoft
    if grep -q "WSL2" /proc/version; then
      echo "Running on WSL2"
    elif grep -q "microsoft" /proc/version; then
      echo "Running on WSL1"
    fi
  fi
}

# Check if a command exists
available() { command -v "$1" >/dev/null; }

# Revert the status, removing containers, volumes, network and folder
cleanup() {
  if [ -d "./../$folder_to_clean" ]; then
    if [ -f "docker-compose.yml" ]; then
      $docker_clean >/dev/null 2>&amp;1
      $docker_remove_volumes >/dev/null 2>&amp;1
    fi
    cd ..
    rm -rf "${folder_to_clean}"
  fi
}

# Generate the error log
# parameter 1: error message
# parameter 2: the container names to retrieve, separated by comma
generate_error_log() {
  msg="$1"
  docker_services="$2"
  error_file="$error_log"
  if [ -d "./../$folder_to_clean" ]; then
    error_file="./../$error_log"
  fi
  if [ -n "${msg}" ]; then
    echo "${msg}" > "$error_file"
  fi
  { 
    echo "Start-local version: ${version}"
    echo "Docker engine: $(docker --version)"
    echo "Docker compose: ${docker_version}"
    get_os_info
  } >> "$error_file" 
  for service in $docker_services; do
    echo "-- Logs of service ${service}:" >> "$error_file"
    docker logs "${service}" >> "$error_file" 2> /dev/null
  done
  echo "An error log has been generated in ${error_log} file."
  echo "If you need assistance, open an issue at https://github.com/elastic/start-local/issues"
}

# Compare versions
# parameter 1: version to compare
# parameter 2: version to compare
compare_versions() {
  v1=$1
  v2=$2

  original_ifs="$IFS"
  IFS=&#39;.&#39;
  # shellcheck disable=SC2086
  set -- $v1; v1_major=${1:-0}; v1_minor=${2:-0}; v1_patch=${3:-0}
  IFS=&#39;.&#39;
  # shellcheck disable=SC2086
  set -- $v2; v2_major=${1:-0}; v2_minor=${2:-0}; v2_patch=${3:-0}
  IFS="$original_ifs"

  [ "$v1_major" -lt "$v2_major" ] && echo "lt" && return 0
  [ "$v1_major" -gt "$v2_major" ] && echo "gt" && return 0

  [ "$v1_minor" -lt "$v2_minor" ] && echo "lt" && return 0
  [ "$v1_minor" -gt "$v2_minor" ] && echo "gt" && return 0

  [ "$v1_patch" -lt "$v2_patch" ] && echo "lt" && return 0
  [ "$v1_patch" -gt "$v2_patch" ] && echo "gt" && return 0

  echo "eq"
}

# Wait for availability of Kibana
# parameter: timeout in seconds
wait_for_kibana() {
  timeout="${1:-60}"
  echo "- Waiting for Kibana to be ready"
  echo
  start_time="$(date +%s)"
  until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do
    elapsed_time="$(($(date +%s) - start_time))"
    if [ "$elapsed_time" -ge "$timeout" ]; then
      error_msg="Error: Kibana timeout of ${timeout} sec"
      echo "$error_msg"
      generate_error_log "${error_msg}" "${elasticsearch_container_name} ${kibana_container_name} kibana-settings"
      cleanup
      exit 1
    fi
    sleep 2
  done
}

# Generates a random password with letters and numbers
# parameter: size of the password (default is 8 characters)
random_password() {
  LENGTH="${1:-8}"
  LC_ALL=C tr -dc &#39;A-Za-z0-9&#39; < /dev/urandom | head -c "${LENGTH}"
}

# Create an API key for Elasticsearch
# parameter 1: the Elasticsearch password
# parameter 2: name of the API key to generate
create_api_key() {
  es_password=$1
  name=$2
  response="$(curl -s -u "elastic:${es_password}" -X POST http://localhost:9200/_security/api_key -d "{\"name\": \"${name}\"}" -H "Content-Type: application/json")"
  if [ -z "$response" ]; then
    echo ""
  else
    api_key="$(echo "$response" | grep -Eo &#39;"encoded":"[A-Za-z0-9+/=]+&#39; | grep -Eo &#39;[A-Za-z0-9+/=]+&#39; | tail -n 1)"
    echo "$api_key"
  fi
}

# Check if a container is runnning
# parameter: the name of the container
check_container_running() {
  container_name=$1
  containers="$(docker ps --format &#39;{{.Names}}&#39;)"
  if echo "$containers" | grep -q "^${container_name}$"; then
    echo "The docker container &#39;$container_name&#39; is already running!"
    echo "You can have only one running at time."
    echo "To stop the container run the following command:"
    echo
    echo "docker stop $container_name"
    exit 1
  fi
}

# Check the available disk space in GB
# parameter: required size in GB
check_disk_space_gb() {
  required=$1
  available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024))
  if [ "$available_gb" -lt "$required" ]; then
    echo "Error: only ${available_gb} GB of disk space available; ${required} GB required for the installation"
    exit 1
  fi
}

check_requirements() {
  # Check the requirements
  check_disk_space_gb ${min_disk_space_required}
  if ! available "curl"; then
    echo "Error: curl command is required"
    echo "You can install it from https://curl.se/download.html."
    exit 1
  fi
  if ! available "grep"; then
    echo "Error: grep command is required"
    echo "You can install it from https://www.gnu.org/software/grep/."
    exit 1
  fi
  need_wait_for_kibana=true
  # Check for "docker compose" or "docker-compose"
  set +e
  if ! docker compose >/dev/null 2>&amp;1; then
    if ! available "docker-compose"; then
      if ! available "docker"; then
        echo "Error: docker command is required"
        echo "You can install it from https://docs.docker.com/engine/install/."
        exit 1
      fi
      echo "Error: docker compose is required"
      echo "You can install it from https://docs.docker.com/compose/install/"
      exit 1
    fi
    docker="docker-compose up -d"
    docker_stop="docker-compose stop"
    docker_clean="docker-compose rm -fsv"
    docker_remove_volumes="docker-compose down -v"
    docker_version=$(docker-compose --version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;)
    if [ "$(compare_versions "$docker_version" "$min_docker_compose")" = "lt" ]; then
      echo "Unfortunately we don&#39;t support docker compose ${docker_version}. The minimum required version is $min_docker_compose."
      echo "You can migrate you docker compose from https://docs.docker.com/compose/migrate/"
      cleanup
      exit 1
    fi 
  else
    docker_stop="docker compose stop"
    docker_clean="docker compose rm -fsv"
    docker_remove_volumes="docker compose down -v"
    docker_version=$(docker compose version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;)
    # --wait option has been introduced in 2.1.1+
    if [ "$(compare_versions "$docker_version" "2.1.0")" = "gt" ]; then
      docker="docker compose up --wait"
      need_wait_for_kibana=false
    else
      docker="docker compose up -d"
    fi
  fi
  set -e
}

check_installation_folder() {
  # Check if $installation_folder exists
  folder=$installation_folder
  if [ -d "$folder" ]; then
    if [ -n "$(ls -A "$folder")" ]; then
      echo "It seems you have already a start-local installation in &#39;${folder}&#39;."
      if [ -f "$folder/uninstall.sh" ]; then
        echo "I cannot proceed unless you uninstall it, using the following command:"
        echo "cd $folder && ./uninstall.sh"
      else
        echo "I did not find the uninstall.sh file, you need to proceed manually."
        if [ -f "$folder/docker-compose.yml" ] && [ -f "$folder/.env" ]; then
          echo "Execute the following commands:"
          echo "cd $folder"
          echo "$docker_clean"
          echo "$docker_remove_volumes"
          echo "cd .."
          echo "rm -rf $folder"
        fi
      fi
      exit 1
    fi
  fi
}

check_docker_services() {
  # Check for docker containers running
  check_container_running "$elasticsearch_container_name"
  check_container_running "$kibana_container_name"
  check_container_running "$kibana_settings_container_name"
}

create_installation_folder() {
  # If $folder already exists, it is empty, see above
  if [ ! -d "$folder" ]; then 
    mkdir "$folder"
  fi
  cd "$folder"
  folder_to_clean=$folder
}

generate_passwords() {
  # Generate random passwords
  es_password="${ES_LOCAL_PASSWORD:-$(random_password)}"
  if  [ -z "${esonly:-}" ]; then
    kibana_password="$(random_password)"
    kibana_encryption_key="$(random_password 32)"
  fi
}

choose_es_version() {
  if [ -z "${es_version:-}" ]; then
    # Get the latest Elasticsearch version
    es_version="$(get_latest_version)"
  fi
  # Fix for ARM64: add suffix "-arm64"
  if is_arm64 && [ "${es_version##*-arm64}" = "$es_version" ]; then
    es_version="${es_version}-arm64"
  fi
}

create_env_file() {
  # Create the .env file
  cat > .env <<- EOM
START_LOCAL_VERSION=$version
ES_LOCAL_VERSION=$es_version
ES_LOCAL_CONTAINER_NAME=$elasticsearch_container_name
ES_LOCAL_PASSWORD=$es_password
ES_LOCAL_PORT=9200
ES_LOCAL_URL=http://localhost:\${ES_LOCAL_PORT}
ES_LOCAL_HEAP_INIT=128m
ES_LOCAL_HEAP_MAX=2g
ES_LOCAL_DISK_SPACE_REQUIRED=1gb
EOM

  if  [ -z "${esonly:-}" ]; then
    cat >> .env <<- EOM
KIBANA_LOCAL_CONTAINER_NAME=$kibana_container_name
KIBANA_LOCAL_SETTINGS_CONTAINER_NAME=$kibana_settings_container_name
KIBANA_LOCAL_PORT=5601
KIBANA_LOCAL_PASSWORD=$kibana_password
KIBANA_ENCRYPTION_KEY=$kibana_encryption_key
EOM
  fi
}

# Create the start script (start.sh)
# including the license update if trial expired
create_start_file() {
  today=$(date +%s)
  expire=$((today + 3600*24*30))

  cat > start.sh <<-&#39;EOM&#39;
#!/bin/sh
# Start script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "${SCRIPT_DIR}"
today=$(date +%s)
. ./.env
# Check disk space
available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024))
required=$(echo "${ES_LOCAL_DISK_SPACE_REQUIRED}" | grep -Eo &#39;[0-9]+&#39;)
if [ "$available_gb" -lt "$required" ]; then
  echo "----------------------------------------------------------------------------"
  echo "WARNING: Disk space is below the ${required} GB limit. Elasticsearch will be"
  echo "executed in read-only mode. Please free up disk space to resolve this issue."
  echo "----------------------------------------------------------------------------"
  echo "Press ENTER to confirm."
  # shellcheck disable=SC2034
  read -r line
fi
EOM
  if [ "$need_wait_for_kibana" = true ]; then
    cat >> start.sh <<-&#39;EOM&#39;
wait_for_kibana() {
  _timeout="${1:-60}"
  echo "- Waiting for Kibana to be ready"
  echo
  _start_time="$(date +%s)"
  until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do
    elapsed_time="$(($(date +%s) - _start_time))"
    if [ "$elapsed_time" -ge "$_timeout" ]; then
      echo "Error: Kibana timeout of ${_timeout} sec"
      exit 1
    fi
    sleep 2
  done
}

EOM
  fi

  cat >> start.sh <<- EOM
if [ -z "\${ES_LOCAL_LICENSE:-}" ] && [ "\$today" -gt $expire ]; then
  echo "---------------------------------------------------------------------"
  echo "The one-month trial period has expired. You can continue using the"
  echo "Free and open Basic license or request to extend the trial for"
  echo "another 30 days using this form:"
  echo "https://www.elastic.co/trialextension"
  echo "---------------------------------------------------------------------"
  echo "For more info about the license: https://www.elastic.co/subscriptions"
  echo
  echo "Updating the license..."
  $docker elasticsearch >/dev/null 2>&amp;1
  result=\$(curl -s -X POST "\${ES_LOCAL_URL}/_license/start_basic?acknowledge=true" -H "Authorization: ApiKey \${ES_LOCAL_API_KEY}" -o /dev/null -w &#39;%{http_code}\n&#39;)
  if [ "\$result" = "200" ]; then
    echo "âœ… Basic license successfully installed"
    echo "ES_LOCAL_LICENSE=basic" >> .env
  else 
    echo "Error: I cannot update the license"
    result=\$(curl -s -X GET "\${ES_LOCAL_URL}" -H "Authorization: ApiKey \${ES_LOCAL_API_KEY}" -o /dev/null -w &#39;%{http_code}\n&#39;)
    if [ "\$result" != "200" ]; then
      echo "Elasticsearch is not running."
    fi
    exit 1
  fi
  echo
fi
$docker
EOM

  if [ "$need_wait_for_kibana" = true ]; then
    cat >> start.sh <<-&#39;EOM&#39;
wait_for_kibana 120
EOM
  fi
  chmod +x start.sh
}

# Create the stop script (stop.sh)
create_stop_file() {
  cat > stop.sh <<-&#39;EOM&#39;
#!/bin/sh
# Stop script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "${SCRIPT_DIR}"
EOM

  cat >> stop.sh <<- EOM
$docker_stop
EOM
  chmod +x stop.sh
}

# Create the uninstall script (uninstall.sh)
create_uninstall_file() {

  cat > uninstall.sh <<-&#39;EOM&#39;
#!/bin/sh
# Uninstall script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

ask_confirmation() {
    echo "Do you confirm? (yes/no)"
    read -r answer
    case "$answer" in
        yes|y|Y|Yes|YES)
            return 0  # true
            ;;
        no|n|N|No|NO)
            return 1  # false
            ;;
        *)
            echo "Please answer yes or no."
            ask_confirmation  # Ask again if the input is invalid
            ;;
    esac
}

cd "${SCRIPT_DIR}"
if [ ! -e "docker-compose.yml" ]; then
  echo "Error: I cannot find the docker-compose.yml file"
  echo "I cannot uninstall start-local."
fi
if [ ! -e ".env" ]; then
  echo "Error: I cannot find the .env file"
  echo "I cannot uninstall start-local."
fi
echo "This script will uninstall start-local."
echo "All data will be deleted and cannot be recovered."
if ask_confirmation; then
EOM

  cat >> uninstall.sh <<- EOM
  $docker_clean
  $docker_remove_volumes
  rm docker-compose.yml .env uninstall.sh start.sh stop.sh config/telemetry.yml
  if [ -z "\$(ls -A config)" ]; then
    rm -d config
  fi
  echo
  echo "Do you want to remove the following Docker images?"
  echo "- docker.elastic.co/elasticsearch/elasticsearch:${es_version}"
EOM

  if  [ -z "${esonly:-}" ]; then
    cat >> uninstall.sh <<- EOM
  echo "- docker.elastic.co/kibana/kibana:${es_version}"
EOM
  fi

  cat >> uninstall.sh <<- EOM
  if ask_confirmation; then
    if docker rmi "docker.elastic.co/elasticsearch/elasticsearch:${es_version}" >/dev/null 2>&amp;1; then
      echo "Image docker.elastic.co/elasticsearch/elasticsearch:${es_version} removed successfully"
    else
      echo "Failed to remove image docker.elastic.co/elasticsearch/elasticsearch:${es_version}. It might be in use."
    fi
EOM

  if  [ -z "${esonly:-}" ]; then
    cat >> uninstall.sh <<- EOM
    if docker rmi docker.elastic.co/kibana/kibana:${es_version} >/dev/null 2>&amp;1; then
      echo "Image docker.elastic.co/kibana/kibana:${es_version} removed successfully"
    else
      echo "Failed to remove image docker.elastic.co/kibana/kibana:${es_version}. It might be in use."
    fi
EOM
  fi

  cat >> uninstall.sh <<- EOM
  fi
  echo "Start-local successfully removed"
fi
EOM
  chmod +x uninstall.sh
}

create_docker_compose_file() {
  # Create the docker-compose-yml file
  cat > docker-compose.yml <<-&#39;EOM&#39;
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION}
    container_name: ${ES_LOCAL_CONTAINER_NAME}
    volumes:
      - dev-elasticsearch:/usr/share/elasticsearch/data
    ports:
      - 127.0.0.1:${ES_LOCAL_PORT}:9200
    environment:
      - discovery.type=single-node
      - ELASTIC_PASSWORD=${ES_LOCAL_PASSWORD}
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=false
      - xpack.license.self_generated.type=trial
      - xpack.ml.use_auto_machine_memory_percent=true
      - ES_JAVA_OPTS=-Xms${ES_LOCAL_HEAP_INIT} -Xmx${ES_LOCAL_HEAP_MAX}
      - cluster.routing.allocation.disk.watermark.low=${ES_LOCAL_DISK_SPACE_REQUIRED}
      - cluster.routing.allocation.disk.watermark.high=${ES_LOCAL_DISK_SPACE_REQUIRED}
      - cluster.routing.allocation.disk.watermark.flood_stage=${ES_LOCAL_DISK_SPACE_REQUIRED}
EOM
  
  # Fix for JDK AArch64 issue, see https://bugs.openjdk.org/browse/JDK-8345296
  if is_arm64; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
      - "_JAVA_OPTIONS=-XX:UseSVE=0"
EOM
  fi

  # Fix for OCI issue on LXC, see https://github.com/elastic/start-local/issues/27
  if ! detect_lxc; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
    ulimits:
      memlock:
        soft: -1
        hard: -1
EOM
  fi

  cat >> docker-compose.yml <<-&#39;EOM&#39;
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl --output /dev/null --silent --head --fail -u elastic:${ES_LOCAL_PASSWORD} http://elasticsearch:9200",
        ]
      interval: 10s
      timeout: 10s
      retries: 30

EOM

if  [ -z "${esonly:-}" ]; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
  kibana_settings:
    depends_on:
      elasticsearch:
        condition: service_healthy
    image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION}
    container_name: ${KIBANA_LOCAL_SETTINGS_CONTAINER_NAME}
    restart: &#39;no&#39;
    command: >
      bash -c &#39;
        echo "Setup the kibana_system password";
        start_time=$$(date +%s);
        timeout=60;
        until curl -s -u "elastic:${ES_LOCAL_PASSWORD}" -X POST http://elasticsearch:9200/_security/user/kibana_system/_password -d "{\"password\":\"${KIBANA_LOCAL_PASSWORD}\"}" -H "Content-Type: application/json" | grep -q "^{}"; do
          if [ $$(($$(date +%s) - $$start_time)) -ge $$timeout ]; then
            echo "Error: Elasticsearch timeout";
            exit 1;
          fi;
          sleep 2;
        done;
      &#39;

  kibana:
    depends_on:
      kibana_settings:
        condition: service_completed_successfully
    image: docker.elastic.co/kibana/kibana:${ES_LOCAL_VERSION}
    container_name: ${KIBANA_LOCAL_CONTAINER_NAME}
    volumes:
      - dev-kibana:/usr/share/kibana/data
      - ./config/telemetry.yml:/usr/share/kibana/config/telemetry.yml
    ports:
      - 127.0.0.1:${KIBANA_LOCAL_PORT}:5601
    environment:
      - SERVER_NAME=kibana
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_PASSWORD=${KIBANA_LOCAL_PASSWORD}
      - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${KIBANA_ENCRYPTION_KEY}
      - ELASTICSEARCH_PUBLICBASEURL=http://localhost:${ES_LOCAL_PORT}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s -I http://kibana:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;",
        ]
      interval: 10s
      timeout: 10s
      retries: 30

EOM
fi

  cat >> docker-compose.yml <<-&#39;EOM&#39;
volumes:
  dev-elasticsearch:
EOM

if  [ -z "${esonly:-}" ]; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
  dev-kibana:
EOM
fi

create_kibana_config
}

create_kibana_config() {
  if [ ! -d "config" ]; then
    mkdir config
  fi
  # Create telemetry
  cat > config/telemetry.yml <<- EOM
start-local:
  version: ${version}
EOM
}

print_steps() {
  if  [ -z "${esonly:-}" ]; then
    echo "âŒ›ï¸ Setting up Elasticsearch and Kibana v${es_version}..."
  else
    echo "âŒ›ï¸ Setting up Elasticsearch v${es_version}..."
  fi
  echo
  echo "- Generated random passwords"
  echo "- Created the ${folder} folder containing the files:"
  echo "  - .env, with settings"
  echo "  - docker-compose.yml, for Docker services"
  echo "  - start/stop/uninstall commands"
}

running_docker_compose() {
  # Execute docker compose
  echo "- Running ${docker}"
  echo
  set +e
  if ! $docker; then
    error_msg="Error: ${docker} command failed!"
    echo "$error_msg"
    if  [ -z "${esonly:-}" ]; then
      generate_error_log "${error_msg}" "${elasticsearch_container_name} ${kibana_container_name} kibana_settings"
    else
      generate_error_log "${error_msg}" "${elasticsearch_container_name}"
    fi
    cleanup
    exit 1
  fi
  set -e
}

api_key() {
  # Create an API key for Elasticsearch
  api_key=$(create_api_key "$es_password" "$api_key_name")
  if [ -n "$api_key" ]; then
    echo "ES_LOCAL_API_KEY=${api_key}" >> .env
  fi
}

kibana_wait() {
  if [ "$need_wait_for_kibana" = true ]; then
    wait_for_kibana 120
  fi
}

success() {
  echo
  if  [ -z "${esonly:-}" ]; then
    echo "ðŸŽ‰ Congrats, Elasticsearch and Kibana are installed and running in Docker!"
    echo
    echo "ðŸŒ Open your browser at http://localhost:5601"
    echo
    echo "   Username: elastic"
    echo "   Password: ${es_password}"
    echo
  else
    echo "ðŸŽ‰ Congrats, Elasticsearch is installed and running in Docker!"
  fi
  
  echo "ðŸ”Œ Elasticsearch API endpoint: http://localhost:9200"
  if [ -n "$api_key" ]; then
    echo "ðŸ”‘ API key: $api_key"
    echo
  else
    echo "ðŸ”‘ Use basic auth or create an API key"
    echo "https://www.elastic.co/guide/en/kibana/current/api-keys.html"
    echo
  fi
  echo
  echo "Learn more at https://github.com/elastic/start-local"

  echo
}

main() {
  parse_args "$@"
  startup
  check_requirements
  check_installation_folder
  check_docker_services
  create_installation_folder
  generate_passwords
  choose_es_version
  create_start_file
  create_stop_file
  create_uninstall_file
  create_env_file
  create_docker_compose_file
  print_steps
  running_docker_compose
  api_key
  kibana_wait
  success
}

ctrl_c() { 
  cleanup
  exit 1
}

# Trap ctrl-c
trap ctrl_c INT

# Execute the script
main "$@"
'><meta name=author content="Me"><link rel=canonical href=https://heyuuuu77.github.io/posts/elasticsearch/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://heyuuuu77.github.io/assets/css/custom.css><script src=https://heyuuuu77.github.io/assets/js/random-gradient.js></script><link rel=icon href=https://heyuuuu77.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://heyuuuu77.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://heyuuuu77.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://heyuuuu77.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://heyuuuu77.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heyuuuu77.github.io/posts/elasticsearch/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://heyuuuu77.github.io/posts/elasticsearch/"><meta property="og:site_name" content="heyuuuu77"><meta property="og:title" content="Elasticsearch"><meta property="og:description" content='start elasticsearch with docker localhost æ‰§è¡Œ
curl -fsSL https://elastic.co/start-local | sh 8DkwaOdk 8DkwaOdk elastic curl -ssSL will get start-local.sh. The content will be:
#!/bin/sh # -------------------------------------------------------- # Run Elasticsearch and Kibana for local testing # Note: do not use this script in a production environment # -------------------------------------------------------- # # Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one # or more contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright # ownership. Elasticsearch B.V. licenses this file to you under # the Apache License, Version 2.0 (the "License"); you may # not use this file except in compliance with the License. # You may obtain a copy of the License at # #	http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, # software distributed under the License is distributed on an # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY # KIND, either express or implied. See the License for the # specific language governing permissions and limitations # under the License. set -eu parse_args() { # Parse the script parameters while [ "$#" -gt 0 ]; do case "$1" in -v) # Check that there is another argument for the version if [ $# -lt 2 ]; then echo "Error: -v requires a version value (eg. -v 8.17.0)" exit 1 fi es_version="$2" shift 2 ;; --esonly) esonly=true shift ;; --) # End of options; shift and exit the loop shift break ;; -*) # Unknown or unsupported option echo "Error: Unknown option &#39;$1&#39;" exit 1 ;; *) # We&#39;ve hit a non-option argument; stop parsing options break ;; esac done } startup() { echo echo &#39; ______ _ _ _ &#39; echo &#39; | ____| | | | (_) &#39; echo &#39; | |__ | | __ _ ___| |_ _ ___ &#39; echo &#39; | __| | |/ _` / __| __| |/ __|&#39; echo &#39; | |____| | (_| \__ \ |_| | (__ &#39; echo &#39; |______|_|\__,_|___/\__|_|\___|&#39; echo &#39;-------------------------------------------------&#39; echo &#39;ðŸš€ Run Elasticsearch and Kibana for local testing&#39; echo &#39;-------------------------------------------------&#39; echo echo &#39;â„¹ï¸ Do not use this script in a production environment&#39; echo # Version version="0.10.0" # Folder name for the installation installation_folder="${ES_LOCAL_DIR:-elastic-start-local}" # API key name for Elasticsearch api_key_name="elastic-start-local" # Name of the error log error_log="error-start-local.log" # Minimum version for docker-compose min_docker_compose="1.29.0" # Elasticsearch container name elasticsearch_container_name="es-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}" # Kibana container name kibana_container_name="kibana-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}" # Kibana settings container name kibana_settings_container_name="kibana-local-settings${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}" # Minimum disk space required for docker images + services (in GB) min_disk_space_required=5 } # Check for ARM64 architecture is_arm64() { arch="$(uname -m)" if [ "$arch" = "arm64" ] || [ "$arch" = "aarch64" ]; then return 0 # Return 0 (true) else return 1 # Return 1 (false) fi } # Alternative to sort -V, which is not available in BSD-based systems (e.g., macOS) version_sort() { awk -F&#39;.&#39; &#39; { printf("%d %d %d %s\n", $1, $2, $3, $0) }&#39; | sort -n -k1,1 -k2,2 -k3,3 | awk &#39;{print $4}&#39; } # Function to check if the format is a valid semantic version (major.minor.patch) is_valid_version() { echo "$1" | grep -E -q &#39;^[0-9]+\.[0-9]+\.[0-9]+$&#39; } # Get the latest stable version of Elasticsearch # Note: It removes all the beta or candidate releases from the list # but includes the GA releases (e.g. new major) get_latest_version() { versions="$(curl -s "https://artifacts.elastic.co/releases/stack.json")" latest_version=$(echo "$versions" | awk -F&#39;"&#39; &#39;/"version": *"/ {print $4}&#39; | grep -E &#39;^[0-9]+\.[0-9]+\.[0-9]+( GA)?$&#39; | version_sort | tail -n 1) # Remove the GA prefix from the version, if present latest_version=$(echo "$latest_version" | awk &#39;{ gsub(/ GA$/, "", $0); print }&#39;) # Check if the latest version is empty if [ -z "$latest_version" ]; then echo "Error: the latest Elasticsearch version is empty" exit 1 fi # Check if the latest version is valid if ! is_valid_version "$latest_version"; then echo "Error: {$latest_version} is not a valid Elasticsearch stable version" exit 1 fi echo "$latest_version" } # Detect if running on LXC container detect_lxc() { # Check /proc/1/environ for LXC container identifier if grep -qa "container=lxc" /proc/1/environ 2>/dev/null; then return 0 fi # Check /proc/self/cgroup for LXC references if grep -q "lxc" /proc/self/cgroup 2>/dev/null; then return 0 fi # Check for LXC in /sys/fs/cgroup if grep -q "lxc" /sys/fs/cgroup/* 2>/dev/null; then return 0 fi # Use systemd-detect-virt if available if command -v systemd-detect-virt >/dev/null 2>&amp;1; then if [ "$(systemd-detect-virt)" = "lxc" ]; then return 0 fi fi return 1 } # Get linux distribution get_os_info() { if [ -f /etc/os-release ]; then # Most modern Linux distributions have this file . /etc/os-release echo "Distribution: $NAME" echo "Version: $VERSION" elif [ -f /etc/lsb-release ]; then # For older distributions using LSB (Linux Standard Base) . /etc/lsb-release echo "Distribution: $DISTRIB_ID" echo "Version: $DISTRIB_RELEASE" elif [ -f /etc/debian_version ]; then # For Debian-based distributions without os-release or lsb-release echo "Distribution: Debian" echo "Version: $(cat /etc/debian_version)" elif [ -f /etc/redhat-release ]; then # For Red Hat-based distributions echo "Distribution: $(cat /etc/redhat-release)" elif [ -n "${OSTYPE+x}" ]; then if [ "${OSTYPE#darwin}" != "$OSTYPE" ]; then # macOS detection echo "Distribution: macOS" echo "Version: $(sw_vers -productVersion)" elif [ "$OSTYPE" = "cygwin" ] || [ "$OSTYPE" = "msys" ] || [ "$OSTYPE" = "win32" ]; then # Windows detection in environments like Git Bash, Cygwin, or MinGW echo "Distribution: Windows" echo "Version: $(cmd.exe /c ver | tr -d &#39;\r&#39;)" elif [ "$OSTYPE" = "linux-gnu" ] && uname -r | grep -q "Microsoft"; then # Windows Subsystem for Linux (WSL) detection echo "Distribution: Windows (WSL)" echo "Version: $(uname -r)" fi else echo "Unknown operating system" fi if [ -f /proc/version ]; then # Check if running on WSL2 or WSL1 for Microsoft if grep -q "WSL2" /proc/version; then echo "Running on WSL2" elif grep -q "microsoft" /proc/version; then echo "Running on WSL1" fi fi } # Check if a command exists available() { command -v "$1" >/dev/null; } # Revert the status, removing containers, volumes, network and folder cleanup() { if [ -d "./../$folder_to_clean" ]; then if [ -f "docker-compose.yml" ]; then $docker_clean >/dev/null 2>&amp;1 $docker_remove_volumes >/dev/null 2>&amp;1 fi cd .. rm -rf "${folder_to_clean}" fi } # Generate the error log # parameter 1: error message # parameter 2: the container names to retrieve, separated by comma generate_error_log() { msg="$1" docker_services="$2" error_file="$error_log" if [ -d "./../$folder_to_clean" ]; then error_file="./../$error_log" fi if [ -n "${msg}" ]; then echo "${msg}" > "$error_file" fi { echo "Start-local version: ${version}" echo "Docker engine: $(docker --version)" echo "Docker compose: ${docker_version}" get_os_info } >> "$error_file" for service in $docker_services; do echo "-- Logs of service ${service}:" >> "$error_file" docker logs "${service}" >> "$error_file" 2> /dev/null done echo "An error log has been generated in ${error_log} file." echo "If you need assistance, open an issue at https://github.com/elastic/start-local/issues" } # Compare versions # parameter 1: version to compare # parameter 2: version to compare compare_versions() { v1=$1 v2=$2 original_ifs="$IFS" IFS=&#39;.&#39; # shellcheck disable=SC2086 set -- $v1; v1_major=${1:-0}; v1_minor=${2:-0}; v1_patch=${3:-0} IFS=&#39;.&#39; # shellcheck disable=SC2086 set -- $v2; v2_major=${1:-0}; v2_minor=${2:-0}; v2_patch=${3:-0} IFS="$original_ifs" [ "$v1_major" -lt "$v2_major" ] && echo "lt" && return 0 [ "$v1_major" -gt "$v2_major" ] && echo "gt" && return 0 [ "$v1_minor" -lt "$v2_minor" ] && echo "lt" && return 0 [ "$v1_minor" -gt "$v2_minor" ] && echo "gt" && return 0 [ "$v1_patch" -lt "$v2_patch" ] && echo "lt" && return 0 [ "$v1_patch" -gt "$v2_patch" ] && echo "gt" && return 0 echo "eq" } # Wait for availability of Kibana # parameter: timeout in seconds wait_for_kibana() { timeout="${1:-60}" echo "- Waiting for Kibana to be ready" echo start_time="$(date +%s)" until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do elapsed_time="$(($(date +%s) - start_time))" if [ "$elapsed_time" -ge "$timeout" ]; then error_msg="Error: Kibana timeout of ${timeout} sec" echo "$error_msg" generate_error_log "${error_msg}" "${elasticsearch_container_name} ${kibana_container_name} kibana-settings" cleanup exit 1 fi sleep 2 done } # Generates a random password with letters and numbers # parameter: size of the password (default is 8 characters) random_password() { LENGTH="${1:-8}" LC_ALL=C tr -dc &#39;A-Za-z0-9&#39; < /dev/urandom | head -c "${LENGTH}" } # Create an API key for Elasticsearch # parameter 1: the Elasticsearch password # parameter 2: name of the API key to generate create_api_key() { es_password=$1 name=$2 response="$(curl -s -u "elastic:${es_password}" -X POST http://localhost:9200/_security/api_key -d "{\"name\": \"${name}\"}" -H "Content-Type: application/json")" if [ -z "$response" ]; then echo "" else api_key="$(echo "$response" | grep -Eo &#39;"encoded":"[A-Za-z0-9+/=]+&#39; | grep -Eo &#39;[A-Za-z0-9+/=]+&#39; | tail -n 1)" echo "$api_key" fi } # Check if a container is runnning # parameter: the name of the container check_container_running() { container_name=$1 containers="$(docker ps --format &#39;{{.Names}}&#39;)" if echo "$containers" | grep -q "^${container_name}$"; then echo "The docker container &#39;$container_name&#39; is already running!" echo "You can have only one running at time." echo "To stop the container run the following command:" echo echo "docker stop $container_name" exit 1 fi } # Check the available disk space in GB # parameter: required size in GB check_disk_space_gb() { required=$1 available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024)) if [ "$available_gb" -lt "$required" ]; then echo "Error: only ${available_gb} GB of disk space available; ${required} GB required for the installation" exit 1 fi } check_requirements() { # Check the requirements check_disk_space_gb ${min_disk_space_required} if ! available "curl"; then echo "Error: curl command is required" echo "You can install it from https://curl.se/download.html." exit 1 fi if ! available "grep"; then echo "Error: grep command is required" echo "You can install it from https://www.gnu.org/software/grep/." exit 1 fi need_wait_for_kibana=true # Check for "docker compose" or "docker-compose" set +e if ! docker compose >/dev/null 2>&amp;1; then if ! available "docker-compose"; then if ! available "docker"; then echo "Error: docker command is required" echo "You can install it from https://docs.docker.com/engine/install/." exit 1 fi echo "Error: docker compose is required" echo "You can install it from https://docs.docker.com/compose/install/" exit 1 fi docker="docker-compose up -d" docker_stop="docker-compose stop" docker_clean="docker-compose rm -fsv" docker_remove_volumes="docker-compose down -v" docker_version=$(docker-compose --version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;) if [ "$(compare_versions "$docker_version" "$min_docker_compose")" = "lt" ]; then echo "Unfortunately we don&#39;t support docker compose ${docker_version}. The minimum required version is $min_docker_compose." echo "You can migrate you docker compose from https://docs.docker.com/compose/migrate/" cleanup exit 1 fi else docker_stop="docker compose stop" docker_clean="docker compose rm -fsv" docker_remove_volumes="docker compose down -v" docker_version=$(docker compose version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;) # --wait option has been introduced in 2.1.1+ if [ "$(compare_versions "$docker_version" "2.1.0")" = "gt" ]; then docker="docker compose up --wait" need_wait_for_kibana=false else docker="docker compose up -d" fi fi set -e } check_installation_folder() { # Check if $installation_folder exists folder=$installation_folder if [ -d "$folder" ]; then if [ -n "$(ls -A "$folder")" ]; then echo "It seems you have already a start-local installation in &#39;${folder}&#39;." if [ -f "$folder/uninstall.sh" ]; then echo "I cannot proceed unless you uninstall it, using the following command:" echo "cd $folder && ./uninstall.sh" else echo "I did not find the uninstall.sh file, you need to proceed manually." if [ -f "$folder/docker-compose.yml" ] && [ -f "$folder/.env" ]; then echo "Execute the following commands:" echo "cd $folder" echo "$docker_clean" echo "$docker_remove_volumes" echo "cd .." echo "rm -rf $folder" fi fi exit 1 fi fi } check_docker_services() { # Check for docker containers running check_container_running "$elasticsearch_container_name" check_container_running "$kibana_container_name" check_container_running "$kibana_settings_container_name" } create_installation_folder() { # If $folder already exists, it is empty, see above if [ ! -d "$folder" ]; then mkdir "$folder" fi cd "$folder" folder_to_clean=$folder } generate_passwords() { # Generate random passwords es_password="${ES_LOCAL_PASSWORD:-$(random_password)}" if [ -z "${esonly:-}" ]; then kibana_password="$(random_password)" kibana_encryption_key="$(random_password 32)" fi } choose_es_version() { if [ -z "${es_version:-}" ]; then # Get the latest Elasticsearch version es_version="$(get_latest_version)" fi # Fix for ARM64: add suffix "-arm64" if is_arm64 && [ "${es_version##*-arm64}" = "$es_version" ]; then es_version="${es_version}-arm64" fi } create_env_file() { # Create the .env file cat > .env <<- EOM START_LOCAL_VERSION=$version ES_LOCAL_VERSION=$es_version ES_LOCAL_CONTAINER_NAME=$elasticsearch_container_name ES_LOCAL_PASSWORD=$es_password ES_LOCAL_PORT=9200 ES_LOCAL_URL=http://localhost:\${ES_LOCAL_PORT} ES_LOCAL_HEAP_INIT=128m ES_LOCAL_HEAP_MAX=2g ES_LOCAL_DISK_SPACE_REQUIRED=1gb EOM if [ -z "${esonly:-}" ]; then cat >> .env <<- EOM KIBANA_LOCAL_CONTAINER_NAME=$kibana_container_name KIBANA_LOCAL_SETTINGS_CONTAINER_NAME=$kibana_settings_container_name KIBANA_LOCAL_PORT=5601 KIBANA_LOCAL_PASSWORD=$kibana_password KIBANA_ENCRYPTION_KEY=$kibana_encryption_key EOM fi } # Create the start script (start.sh) # including the license update if trial expired create_start_file() { today=$(date +%s) expire=$((today + 3600*24*30)) cat > start.sh <<-&#39;EOM&#39; #!/bin/sh # Start script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)" cd "${SCRIPT_DIR}" today=$(date +%s) . ./.env # Check disk space available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024)) required=$(echo "${ES_LOCAL_DISK_SPACE_REQUIRED}" | grep -Eo &#39;[0-9]+&#39;) if [ "$available_gb" -lt "$required" ]; then echo "----------------------------------------------------------------------------" echo "WARNING: Disk space is below the ${required} GB limit. Elasticsearch will be" echo "executed in read-only mode. Please free up disk space to resolve this issue." echo "----------------------------------------------------------------------------" echo "Press ENTER to confirm." # shellcheck disable=SC2034 read -r line fi EOM if [ "$need_wait_for_kibana" = true ]; then cat >> start.sh <<-&#39;EOM&#39; wait_for_kibana() { _timeout="${1:-60}" echo "- Waiting for Kibana to be ready" echo _start_time="$(date +%s)" until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do elapsed_time="$(($(date +%s) - _start_time))" if [ "$elapsed_time" -ge "$_timeout" ]; then echo "Error: Kibana timeout of ${_timeout} sec" exit 1 fi sleep 2 done } EOM fi cat >> start.sh <<- EOM if [ -z "\${ES_LOCAL_LICENSE:-}" ] && [ "\$today" -gt $expire ]; then echo "---------------------------------------------------------------------" echo "The one-month trial period has expired. You can continue using the" echo "Free and open Basic license or request to extend the trial for" echo "another 30 days using this form:" echo "https://www.elastic.co/trialextension" echo "---------------------------------------------------------------------" echo "For more info about the license: https://www.elastic.co/subscriptions" echo echo "Updating the license..." $docker elasticsearch >/dev/null 2>&amp;1 result=\$(curl -s -X POST "\${ES_LOCAL_URL}/_license/start_basic?acknowledge=true" -H "Authorization: ApiKey \${ES_LOCAL_API_KEY}" -o /dev/null -w &#39;%{http_code}\n&#39;) if [ "\$result" = "200" ]; then echo "âœ… Basic license successfully installed" echo "ES_LOCAL_LICENSE=basic" >> .env else echo "Error: I cannot update the license" result=\$(curl -s -X GET "\${ES_LOCAL_URL}" -H "Authorization: ApiKey \${ES_LOCAL_API_KEY}" -o /dev/null -w &#39;%{http_code}\n&#39;) if [ "\$result" != "200" ]; then echo "Elasticsearch is not running." fi exit 1 fi echo fi $docker EOM if [ "$need_wait_for_kibana" = true ]; then cat >> start.sh <<-&#39;EOM&#39; wait_for_kibana 120 EOM fi chmod +x start.sh } # Create the stop script (stop.sh) create_stop_file() { cat > stop.sh <<-&#39;EOM&#39; #!/bin/sh # Stop script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)" cd "${SCRIPT_DIR}" EOM cat >> stop.sh <<- EOM $docker_stop EOM chmod +x stop.sh } # Create the uninstall script (uninstall.sh) create_uninstall_file() { cat > uninstall.sh <<-&#39;EOM&#39; #!/bin/sh # Uninstall script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)" ask_confirmation() { echo "Do you confirm? (yes/no)" read -r answer case "$answer" in yes|y|Y|Yes|YES) return 0 # true ;; no|n|N|No|NO) return 1 # false ;; *) echo "Please answer yes or no." ask_confirmation # Ask again if the input is invalid ;; esac } cd "${SCRIPT_DIR}" if [ ! -e "docker-compose.yml" ]; then echo "Error: I cannot find the docker-compose.yml file" echo "I cannot uninstall start-local." fi if [ ! -e ".env" ]; then echo "Error: I cannot find the .env file" echo "I cannot uninstall start-local." fi echo "This script will uninstall start-local." echo "All data will be deleted and cannot be recovered." if ask_confirmation; then EOM cat >> uninstall.sh <<- EOM $docker_clean $docker_remove_volumes rm docker-compose.yml .env uninstall.sh start.sh stop.sh config/telemetry.yml if [ -z "\$(ls -A config)" ]; then rm -d config fi echo echo "Do you want to remove the following Docker images?" echo "- docker.elastic.co/elasticsearch/elasticsearch:${es_version}" EOM if [ -z "${esonly:-}" ]; then cat >> uninstall.sh <<- EOM echo "- docker.elastic.co/kibana/kibana:${es_version}" EOM fi cat >> uninstall.sh <<- EOM if ask_confirmation; then if docker rmi "docker.elastic.co/elasticsearch/elasticsearch:${es_version}" >/dev/null 2>&amp;1; then echo "Image docker.elastic.co/elasticsearch/elasticsearch:${es_version} removed successfully" else echo "Failed to remove image docker.elastic.co/elasticsearch/elasticsearch:${es_version}. It might be in use." fi EOM if [ -z "${esonly:-}" ]; then cat >> uninstall.sh <<- EOM if docker rmi docker.elastic.co/kibana/kibana:${es_version} >/dev/null 2>&amp;1; then echo "Image docker.elastic.co/kibana/kibana:${es_version} removed successfully" else echo "Failed to remove image docker.elastic.co/kibana/kibana:${es_version}. It might be in use." fi EOM fi cat >> uninstall.sh <<- EOM fi echo "Start-local successfully removed" fi EOM chmod +x uninstall.sh } create_docker_compose_file() { # Create the docker-compose-yml file cat > docker-compose.yml <<-&#39;EOM&#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION} container_name: ${ES_LOCAL_CONTAINER_NAME} volumes: - dev-elasticsearch:/usr/share/elasticsearch/data ports: - 127.0.0.1:${ES_LOCAL_PORT}:9200 environment: - discovery.type=single-node - ELASTIC_PASSWORD=${ES_LOCAL_PASSWORD} - xpack.security.enabled=true - xpack.security.http.ssl.enabled=false - xpack.license.self_generated.type=trial - xpack.ml.use_auto_machine_memory_percent=true - ES_JAVA_OPTS=-Xms${ES_LOCAL_HEAP_INIT} -Xmx${ES_LOCAL_HEAP_MAX} - cluster.routing.allocation.disk.watermark.low=${ES_LOCAL_DISK_SPACE_REQUIRED} - cluster.routing.allocation.disk.watermark.high=${ES_LOCAL_DISK_SPACE_REQUIRED} - cluster.routing.allocation.disk.watermark.flood_stage=${ES_LOCAL_DISK_SPACE_REQUIRED} EOM # Fix for JDK AArch64 issue, see https://bugs.openjdk.org/browse/JDK-8345296 if is_arm64; then cat >> docker-compose.yml <<-&#39;EOM&#39; - "_JAVA_OPTIONS=-XX:UseSVE=0" EOM fi # Fix for OCI issue on LXC, see https://github.com/elastic/start-local/issues/27 if ! detect_lxc; then cat >> docker-compose.yml <<-&#39;EOM&#39; ulimits: memlock: soft: -1 hard: -1 EOM fi cat >> docker-compose.yml <<-&#39;EOM&#39; healthcheck: test: [ "CMD-SHELL", "curl --output /dev/null --silent --head --fail -u elastic:${ES_LOCAL_PASSWORD} http://elasticsearch:9200", ] interval: 10s timeout: 10s retries: 30 EOM if [ -z "${esonly:-}" ]; then cat >> docker-compose.yml <<-&#39;EOM&#39; kibana_settings: depends_on: elasticsearch: condition: service_healthy image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION} container_name: ${KIBANA_LOCAL_SETTINGS_CONTAINER_NAME} restart: &#39;no&#39; command: > bash -c &#39; echo "Setup the kibana_system password"; start_time=$$(date +%s); timeout=60; until curl -s -u "elastic:${ES_LOCAL_PASSWORD}" -X POST http://elasticsearch:9200/_security/user/kibana_system/_password -d "{\"password\":\"${KIBANA_LOCAL_PASSWORD}\"}" -H "Content-Type: application/json" | grep -q "^{}"; do if [ $$(($$(date +%s) - $$start_time)) -ge $$timeout ]; then echo "Error: Elasticsearch timeout"; exit 1; fi; sleep 2; done; &#39; kibana: depends_on: kibana_settings: condition: service_completed_successfully image: docker.elastic.co/kibana/kibana:${ES_LOCAL_VERSION} container_name: ${KIBANA_LOCAL_CONTAINER_NAME} volumes: - dev-kibana:/usr/share/kibana/data - ./config/telemetry.yml:/usr/share/kibana/config/telemetry.yml ports: - 127.0.0.1:${KIBANA_LOCAL_PORT}:5601 environment: - SERVER_NAME=kibana - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=${KIBANA_LOCAL_PASSWORD} - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${KIBANA_ENCRYPTION_KEY} - ELASTICSEARCH_PUBLICBASEURL=http://localhost:${ES_LOCAL_PORT} healthcheck: test: [ "CMD-SHELL", "curl -s -I http://kibana:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;", ] interval: 10s timeout: 10s retries: 30 EOM fi cat >> docker-compose.yml <<-&#39;EOM&#39; volumes: dev-elasticsearch: EOM if [ -z "${esonly:-}" ]; then cat >> docker-compose.yml <<-&#39;EOM&#39; dev-kibana: EOM fi create_kibana_config } create_kibana_config() { if [ ! -d "config" ]; then mkdir config fi # Create telemetry cat > config/telemetry.yml <<- EOM start-local: version: ${version} EOM } print_steps() { if [ -z "${esonly:-}" ]; then echo "âŒ›ï¸ Setting up Elasticsearch and Kibana v${es_version}..." else echo "âŒ›ï¸ Setting up Elasticsearch v${es_version}..." fi echo echo "- Generated random passwords" echo "- Created the ${folder} folder containing the files:" echo " - .env, with settings" echo " - docker-compose.yml, for Docker services" echo " - start/stop/uninstall commands" } running_docker_compose() { # Execute docker compose echo "- Running ${docker}" echo set +e if ! $docker; then error_msg="Error: ${docker} command failed!" echo "$error_msg" if [ -z "${esonly:-}" ]; then generate_error_log "${error_msg}" "${elasticsearch_container_name} ${kibana_container_name} kibana_settings" else generate_error_log "${error_msg}" "${elasticsearch_container_name}" fi cleanup exit 1 fi set -e } api_key() { # Create an API key for Elasticsearch api_key=$(create_api_key "$es_password" "$api_key_name") if [ -n "$api_key" ]; then echo "ES_LOCAL_API_KEY=${api_key}" >> .env fi } kibana_wait() { if [ "$need_wait_for_kibana" = true ]; then wait_for_kibana 120 fi } success() { echo if [ -z "${esonly:-}" ]; then echo "ðŸŽ‰ Congrats, Elasticsearch and Kibana are installed and running in Docker!" echo echo "ðŸŒ Open your browser at http://localhost:5601" echo echo " Username: elastic" echo " Password: ${es_password}" echo else echo "ðŸŽ‰ Congrats, Elasticsearch is installed and running in Docker!" fi echo "ðŸ”Œ Elasticsearch API endpoint: http://localhost:9200" if [ -n "$api_key" ]; then echo "ðŸ”‘ API key: $api_key" echo else echo "ðŸ”‘ Use basic auth or create an API key" echo "https://www.elastic.co/guide/en/kibana/current/api-keys.html" echo fi echo echo "Learn more at https://github.com/elastic/start-local" echo } main() { parse_args "$@" startup check_requirements check_installation_folder check_docker_services create_installation_folder generate_passwords choose_es_version create_start_file create_stop_file create_uninstall_file create_env_file create_docker_compose_file print_steps running_docker_compose api_key kibana_wait success } ctrl_c() { cleanup exit 1 } # Trap ctrl-c trap ctrl_c INT # Execute the script main "$@" '><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-30T20:06:04+08:00"><meta property="article:modified_time" content="2025-07-30T20:06:04+08:00"><meta property="og:image" content="https://heyuuuu77.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://heyuuuu77.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Elasticsearch"><meta name=twitter:description content='start elasticsearch with docker localhost
æ‰§è¡Œ
curl -fsSL https://elastic.co/start-local | sh 8DkwaOdk 8DkwaOdk elastic
curl -ssSL will get start-local.sh. The content will be:

#!/bin/sh
# --------------------------------------------------------
# Run Elasticsearch and Kibana for local testing
# Note: do not use this script in a production environment
# --------------------------------------------------------
#
# Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
# or more contributor license agreements. See the NOTICE file distributed with
# this work for additional information regarding copyright
# ownership. Elasticsearch B.V. licenses this file to you under
# the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
set -eu

parse_args() {
  # Parse the script parameters
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -v)
        # Check that there is another argument for the version
        if [ $# -lt 2 ]; then
          echo "Error: -v requires a version value (eg. -v 8.17.0)"
          exit 1
        fi
        es_version="$2"
        shift 2
        ;;

      --esonly)
        esonly=true
        shift
        ;;

      --)
        # End of options; shift and exit the loop
        shift
        break
        ;;

      -*)
        # Unknown or unsupported option
        echo "Error: Unknown option &#39;$1&#39;"
        exit 1
        ;;

      *)
        # We&#39;ve hit a non-option argument; stop parsing options
        break
        ;;
    esac
  done
}

startup() {
  echo
  echo &#39;  ______ _           _   _      &#39;
  echo &#39; |  ____| |         | | (_)     &#39;
  echo &#39; | |__  | | __ _ ___| |_ _  ___ &#39;
  echo &#39; |  __| | |/ _` / __| __| |/ __|&#39;
  echo &#39; | |____| | (_| \__ \ |_| | (__ &#39;
  echo &#39; |______|_|\__,_|___/\__|_|\___|&#39;
  echo &#39;-------------------------------------------------&#39;
  echo &#39;ðŸš€ Run Elasticsearch and Kibana for local testing&#39;
  echo &#39;-------------------------------------------------&#39;
  echo 
  echo &#39;â„¹ï¸  Do not use this script in a production environment&#39;
  echo

  # Version
  version="0.10.0"

  # Folder name for the installation
  installation_folder="${ES_LOCAL_DIR:-elastic-start-local}"
  # API key name for Elasticsearch
  api_key_name="elastic-start-local"
  # Name of the error log
  error_log="error-start-local.log"
  # Minimum version for docker-compose
  min_docker_compose="1.29.0"
  # Elasticsearch container name
  elasticsearch_container_name="es-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}"
  # Kibana container name
  kibana_container_name="kibana-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}"
  # Kibana settings container name
  kibana_settings_container_name="kibana-local-settings${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}"
  # Minimum disk space required for docker images + services (in GB)
  min_disk_space_required=5
}

# Check for ARM64 architecture
is_arm64() {
  arch="$(uname -m)"
  if [ "$arch" = "arm64" ] || [ "$arch" = "aarch64" ]; then
    return 0 # Return 0 (true)
  else
    return 1 # Return 1 (false)
  fi
}

# Alternative to sort -V, which is not available in BSD-based systems (e.g., macOS)
version_sort() {
  awk -F&#39;.&#39; &#39;
  {
      printf("%d %d %d %s\n", $1, $2, $3, $0)
  }&#39; | sort -n -k1,1 -k2,2 -k3,3 | awk &#39;{print $4}&#39;
}

# Function to check if the format is a valid semantic version (major.minor.patch)
is_valid_version() {
  echo "$1" | grep -E -q &#39;^[0-9]+\.[0-9]+\.[0-9]+$&#39;
}

# Get the latest stable version of Elasticsearch
# Note: It removes all the beta or candidate releases from the list
# but includes the GA releases (e.g. new major)
get_latest_version() {
  versions="$(curl -s "https://artifacts.elastic.co/releases/stack.json")"
  latest_version=$(echo "$versions" | awk -F&#39;"&#39; &#39;/"version": *"/ {print $4}&#39; | grep -E &#39;^[0-9]+\.[0-9]+\.[0-9]+( GA)?$&#39; | version_sort | tail -n 1)
  # Remove the GA prefix from the version, if present
  latest_version=$(echo "$latest_version" | awk &#39;{ gsub(/ GA$/, "", $0); print }&#39;)

  # Check if the latest version is empty
  if [ -z "$latest_version" ]; then
    echo "Error: the latest Elasticsearch version is empty"
    exit 1
  fi
  # Check if the latest version is valid
  if ! is_valid_version "$latest_version"; then
    echo "Error: {$latest_version} is not a valid Elasticsearch stable version"
    exit 1
  fi

  echo "$latest_version"
}

# Detect if running on LXC container
detect_lxc() {
    # Check /proc/1/environ for LXC container identifier
    if grep -qa "container=lxc" /proc/1/environ 2>/dev/null; then
      return 0
    fi
    # Check /proc/self/cgroup for LXC references
    if grep -q "lxc" /proc/self/cgroup 2>/dev/null; then
      return 0
    fi
    # Check for LXC in /sys/fs/cgroup
    if grep -q "lxc" /sys/fs/cgroup/* 2>/dev/null; then  
      return 0
    fi
    # Use systemd-detect-virt if available
    if command -v systemd-detect-virt >/dev/null 2>&amp;1; then
      if [ "$(systemd-detect-virt)" = "lxc" ]; then
        return 0
      fi
    fi
    return 1
}

# Get linux distribution
get_os_info() {
  if [ -f /etc/os-release ]; then
      # Most modern Linux distributions have this file
      . /etc/os-release
      echo "Distribution: $NAME"
      echo "Version: $VERSION"
  elif [ -f /etc/lsb-release ]; then
      # For older distributions using LSB (Linux Standard Base)
      . /etc/lsb-release
      echo "Distribution: $DISTRIB_ID"
      echo "Version: $DISTRIB_RELEASE"
  elif [ -f /etc/debian_version ]; then
      # For Debian-based distributions without os-release or lsb-release
      echo "Distribution: Debian"
      echo "Version: $(cat /etc/debian_version)"
  elif [ -f /etc/redhat-release ]; then
      # For Red Hat-based distributions
      echo "Distribution: $(cat /etc/redhat-release)"
  elif [ -n "${OSTYPE+x}" ]; then
    if [ "${OSTYPE#darwin}" != "$OSTYPE" ]; then
        # macOS detection
        echo "Distribution: macOS"
        echo "Version: $(sw_vers -productVersion)"
    elif [ "$OSTYPE" = "cygwin" ] || [ "$OSTYPE" = "msys" ] || [ "$OSTYPE" = "win32" ]; then
        # Windows detection in environments like Git Bash, Cygwin, or MinGW
        echo "Distribution: Windows"
        echo "Version: $(cmd.exe /c ver | tr -d &#39;\r&#39;)"
    elif [ "$OSTYPE" = "linux-gnu" ] && uname -r | grep -q "Microsoft"; then
        # Windows Subsystem for Linux (WSL) detection
        echo "Distribution: Windows (WSL)"
        echo "Version: $(uname -r)"
    fi
  else
      echo "Unknown operating system"
  fi
  if [ -f /proc/version ]; then
    # Check if running on WSL2 or WSL1 for Microsoft
    if grep -q "WSL2" /proc/version; then
      echo "Running on WSL2"
    elif grep -q "microsoft" /proc/version; then
      echo "Running on WSL1"
    fi
  fi
}

# Check if a command exists
available() { command -v "$1" >/dev/null; }

# Revert the status, removing containers, volumes, network and folder
cleanup() {
  if [ -d "./../$folder_to_clean" ]; then
    if [ -f "docker-compose.yml" ]; then
      $docker_clean >/dev/null 2>&amp;1
      $docker_remove_volumes >/dev/null 2>&amp;1
    fi
    cd ..
    rm -rf "${folder_to_clean}"
  fi
}

# Generate the error log
# parameter 1: error message
# parameter 2: the container names to retrieve, separated by comma
generate_error_log() {
  msg="$1"
  docker_services="$2"
  error_file="$error_log"
  if [ -d "./../$folder_to_clean" ]; then
    error_file="./../$error_log"
  fi
  if [ -n "${msg}" ]; then
    echo "${msg}" > "$error_file"
  fi
  { 
    echo "Start-local version: ${version}"
    echo "Docker engine: $(docker --version)"
    echo "Docker compose: ${docker_version}"
    get_os_info
  } >> "$error_file" 
  for service in $docker_services; do
    echo "-- Logs of service ${service}:" >> "$error_file"
    docker logs "${service}" >> "$error_file" 2> /dev/null
  done
  echo "An error log has been generated in ${error_log} file."
  echo "If you need assistance, open an issue at https://github.com/elastic/start-local/issues"
}

# Compare versions
# parameter 1: version to compare
# parameter 2: version to compare
compare_versions() {
  v1=$1
  v2=$2

  original_ifs="$IFS"
  IFS=&#39;.&#39;
  # shellcheck disable=SC2086
  set -- $v1; v1_major=${1:-0}; v1_minor=${2:-0}; v1_patch=${3:-0}
  IFS=&#39;.&#39;
  # shellcheck disable=SC2086
  set -- $v2; v2_major=${1:-0}; v2_minor=${2:-0}; v2_patch=${3:-0}
  IFS="$original_ifs"

  [ "$v1_major" -lt "$v2_major" ] && echo "lt" && return 0
  [ "$v1_major" -gt "$v2_major" ] && echo "gt" && return 0

  [ "$v1_minor" -lt "$v2_minor" ] && echo "lt" && return 0
  [ "$v1_minor" -gt "$v2_minor" ] && echo "gt" && return 0

  [ "$v1_patch" -lt "$v2_patch" ] && echo "lt" && return 0
  [ "$v1_patch" -gt "$v2_patch" ] && echo "gt" && return 0

  echo "eq"
}

# Wait for availability of Kibana
# parameter: timeout in seconds
wait_for_kibana() {
  timeout="${1:-60}"
  echo "- Waiting for Kibana to be ready"
  echo
  start_time="$(date +%s)"
  until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do
    elapsed_time="$(($(date +%s) - start_time))"
    if [ "$elapsed_time" -ge "$timeout" ]; then
      error_msg="Error: Kibana timeout of ${timeout} sec"
      echo "$error_msg"
      generate_error_log "${error_msg}" "${elasticsearch_container_name} ${kibana_container_name} kibana-settings"
      cleanup
      exit 1
    fi
    sleep 2
  done
}

# Generates a random password with letters and numbers
# parameter: size of the password (default is 8 characters)
random_password() {
  LENGTH="${1:-8}"
  LC_ALL=C tr -dc &#39;A-Za-z0-9&#39; < /dev/urandom | head -c "${LENGTH}"
}

# Create an API key for Elasticsearch
# parameter 1: the Elasticsearch password
# parameter 2: name of the API key to generate
create_api_key() {
  es_password=$1
  name=$2
  response="$(curl -s -u "elastic:${es_password}" -X POST http://localhost:9200/_security/api_key -d "{\"name\": \"${name}\"}" -H "Content-Type: application/json")"
  if [ -z "$response" ]; then
    echo ""
  else
    api_key="$(echo "$response" | grep -Eo &#39;"encoded":"[A-Za-z0-9+/=]+&#39; | grep -Eo &#39;[A-Za-z0-9+/=]+&#39; | tail -n 1)"
    echo "$api_key"
  fi
}

# Check if a container is runnning
# parameter: the name of the container
check_container_running() {
  container_name=$1
  containers="$(docker ps --format &#39;{{.Names}}&#39;)"
  if echo "$containers" | grep -q "^${container_name}$"; then
    echo "The docker container &#39;$container_name&#39; is already running!"
    echo "You can have only one running at time."
    echo "To stop the container run the following command:"
    echo
    echo "docker stop $container_name"
    exit 1
  fi
}

# Check the available disk space in GB
# parameter: required size in GB
check_disk_space_gb() {
  required=$1
  available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024))
  if [ "$available_gb" -lt "$required" ]; then
    echo "Error: only ${available_gb} GB of disk space available; ${required} GB required for the installation"
    exit 1
  fi
}

check_requirements() {
  # Check the requirements
  check_disk_space_gb ${min_disk_space_required}
  if ! available "curl"; then
    echo "Error: curl command is required"
    echo "You can install it from https://curl.se/download.html."
    exit 1
  fi
  if ! available "grep"; then
    echo "Error: grep command is required"
    echo "You can install it from https://www.gnu.org/software/grep/."
    exit 1
  fi
  need_wait_for_kibana=true
  # Check for "docker compose" or "docker-compose"
  set +e
  if ! docker compose >/dev/null 2>&amp;1; then
    if ! available "docker-compose"; then
      if ! available "docker"; then
        echo "Error: docker command is required"
        echo "You can install it from https://docs.docker.com/engine/install/."
        exit 1
      fi
      echo "Error: docker compose is required"
      echo "You can install it from https://docs.docker.com/compose/install/"
      exit 1
    fi
    docker="docker-compose up -d"
    docker_stop="docker-compose stop"
    docker_clean="docker-compose rm -fsv"
    docker_remove_volumes="docker-compose down -v"
    docker_version=$(docker-compose --version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;)
    if [ "$(compare_versions "$docker_version" "$min_docker_compose")" = "lt" ]; then
      echo "Unfortunately we don&#39;t support docker compose ${docker_version}. The minimum required version is $min_docker_compose."
      echo "You can migrate you docker compose from https://docs.docker.com/compose/migrate/"
      cleanup
      exit 1
    fi 
  else
    docker_stop="docker compose stop"
    docker_clean="docker compose rm -fsv"
    docker_remove_volumes="docker compose down -v"
    docker_version=$(docker compose version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;)
    # --wait option has been introduced in 2.1.1+
    if [ "$(compare_versions "$docker_version" "2.1.0")" = "gt" ]; then
      docker="docker compose up --wait"
      need_wait_for_kibana=false
    else
      docker="docker compose up -d"
    fi
  fi
  set -e
}

check_installation_folder() {
  # Check if $installation_folder exists
  folder=$installation_folder
  if [ -d "$folder" ]; then
    if [ -n "$(ls -A "$folder")" ]; then
      echo "It seems you have already a start-local installation in &#39;${folder}&#39;."
      if [ -f "$folder/uninstall.sh" ]; then
        echo "I cannot proceed unless you uninstall it, using the following command:"
        echo "cd $folder && ./uninstall.sh"
      else
        echo "I did not find the uninstall.sh file, you need to proceed manually."
        if [ -f "$folder/docker-compose.yml" ] && [ -f "$folder/.env" ]; then
          echo "Execute the following commands:"
          echo "cd $folder"
          echo "$docker_clean"
          echo "$docker_remove_volumes"
          echo "cd .."
          echo "rm -rf $folder"
        fi
      fi
      exit 1
    fi
  fi
}

check_docker_services() {
  # Check for docker containers running
  check_container_running "$elasticsearch_container_name"
  check_container_running "$kibana_container_name"
  check_container_running "$kibana_settings_container_name"
}

create_installation_folder() {
  # If $folder already exists, it is empty, see above
  if [ ! -d "$folder" ]; then 
    mkdir "$folder"
  fi
  cd "$folder"
  folder_to_clean=$folder
}

generate_passwords() {
  # Generate random passwords
  es_password="${ES_LOCAL_PASSWORD:-$(random_password)}"
  if  [ -z "${esonly:-}" ]; then
    kibana_password="$(random_password)"
    kibana_encryption_key="$(random_password 32)"
  fi
}

choose_es_version() {
  if [ -z "${es_version:-}" ]; then
    # Get the latest Elasticsearch version
    es_version="$(get_latest_version)"
  fi
  # Fix for ARM64: add suffix "-arm64"
  if is_arm64 && [ "${es_version##*-arm64}" = "$es_version" ]; then
    es_version="${es_version}-arm64"
  fi
}

create_env_file() {
  # Create the .env file
  cat > .env <<- EOM
START_LOCAL_VERSION=$version
ES_LOCAL_VERSION=$es_version
ES_LOCAL_CONTAINER_NAME=$elasticsearch_container_name
ES_LOCAL_PASSWORD=$es_password
ES_LOCAL_PORT=9200
ES_LOCAL_URL=http://localhost:\${ES_LOCAL_PORT}
ES_LOCAL_HEAP_INIT=128m
ES_LOCAL_HEAP_MAX=2g
ES_LOCAL_DISK_SPACE_REQUIRED=1gb
EOM

  if  [ -z "${esonly:-}" ]; then
    cat >> .env <<- EOM
KIBANA_LOCAL_CONTAINER_NAME=$kibana_container_name
KIBANA_LOCAL_SETTINGS_CONTAINER_NAME=$kibana_settings_container_name
KIBANA_LOCAL_PORT=5601
KIBANA_LOCAL_PASSWORD=$kibana_password
KIBANA_ENCRYPTION_KEY=$kibana_encryption_key
EOM
  fi
}

# Create the start script (start.sh)
# including the license update if trial expired
create_start_file() {
  today=$(date +%s)
  expire=$((today + 3600*24*30))

  cat > start.sh <<-&#39;EOM&#39;
#!/bin/sh
# Start script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "${SCRIPT_DIR}"
today=$(date +%s)
. ./.env
# Check disk space
available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024))
required=$(echo "${ES_LOCAL_DISK_SPACE_REQUIRED}" | grep -Eo &#39;[0-9]+&#39;)
if [ "$available_gb" -lt "$required" ]; then
  echo "----------------------------------------------------------------------------"
  echo "WARNING: Disk space is below the ${required} GB limit. Elasticsearch will be"
  echo "executed in read-only mode. Please free up disk space to resolve this issue."
  echo "----------------------------------------------------------------------------"
  echo "Press ENTER to confirm."
  # shellcheck disable=SC2034
  read -r line
fi
EOM
  if [ "$need_wait_for_kibana" = true ]; then
    cat >> start.sh <<-&#39;EOM&#39;
wait_for_kibana() {
  _timeout="${1:-60}"
  echo "- Waiting for Kibana to be ready"
  echo
  _start_time="$(date +%s)"
  until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do
    elapsed_time="$(($(date +%s) - _start_time))"
    if [ "$elapsed_time" -ge "$_timeout" ]; then
      echo "Error: Kibana timeout of ${_timeout} sec"
      exit 1
    fi
    sleep 2
  done
}

EOM
  fi

  cat >> start.sh <<- EOM
if [ -z "\${ES_LOCAL_LICENSE:-}" ] && [ "\$today" -gt $expire ]; then
  echo "---------------------------------------------------------------------"
  echo "The one-month trial period has expired. You can continue using the"
  echo "Free and open Basic license or request to extend the trial for"
  echo "another 30 days using this form:"
  echo "https://www.elastic.co/trialextension"
  echo "---------------------------------------------------------------------"
  echo "For more info about the license: https://www.elastic.co/subscriptions"
  echo
  echo "Updating the license..."
  $docker elasticsearch >/dev/null 2>&amp;1
  result=\$(curl -s -X POST "\${ES_LOCAL_URL}/_license/start_basic?acknowledge=true" -H "Authorization: ApiKey \${ES_LOCAL_API_KEY}" -o /dev/null -w &#39;%{http_code}\n&#39;)
  if [ "\$result" = "200" ]; then
    echo "âœ… Basic license successfully installed"
    echo "ES_LOCAL_LICENSE=basic" >> .env
  else 
    echo "Error: I cannot update the license"
    result=\$(curl -s -X GET "\${ES_LOCAL_URL}" -H "Authorization: ApiKey \${ES_LOCAL_API_KEY}" -o /dev/null -w &#39;%{http_code}\n&#39;)
    if [ "\$result" != "200" ]; then
      echo "Elasticsearch is not running."
    fi
    exit 1
  fi
  echo
fi
$docker
EOM

  if [ "$need_wait_for_kibana" = true ]; then
    cat >> start.sh <<-&#39;EOM&#39;
wait_for_kibana 120
EOM
  fi
  chmod +x start.sh
}

# Create the stop script (stop.sh)
create_stop_file() {
  cat > stop.sh <<-&#39;EOM&#39;
#!/bin/sh
# Stop script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "${SCRIPT_DIR}"
EOM

  cat >> stop.sh <<- EOM
$docker_stop
EOM
  chmod +x stop.sh
}

# Create the uninstall script (uninstall.sh)
create_uninstall_file() {

  cat > uninstall.sh <<-&#39;EOM&#39;
#!/bin/sh
# Uninstall script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

ask_confirmation() {
    echo "Do you confirm? (yes/no)"
    read -r answer
    case "$answer" in
        yes|y|Y|Yes|YES)
            return 0  # true
            ;;
        no|n|N|No|NO)
            return 1  # false
            ;;
        *)
            echo "Please answer yes or no."
            ask_confirmation  # Ask again if the input is invalid
            ;;
    esac
}

cd "${SCRIPT_DIR}"
if [ ! -e "docker-compose.yml" ]; then
  echo "Error: I cannot find the docker-compose.yml file"
  echo "I cannot uninstall start-local."
fi
if [ ! -e ".env" ]; then
  echo "Error: I cannot find the .env file"
  echo "I cannot uninstall start-local."
fi
echo "This script will uninstall start-local."
echo "All data will be deleted and cannot be recovered."
if ask_confirmation; then
EOM

  cat >> uninstall.sh <<- EOM
  $docker_clean
  $docker_remove_volumes
  rm docker-compose.yml .env uninstall.sh start.sh stop.sh config/telemetry.yml
  if [ -z "\$(ls -A config)" ]; then
    rm -d config
  fi
  echo
  echo "Do you want to remove the following Docker images?"
  echo "- docker.elastic.co/elasticsearch/elasticsearch:${es_version}"
EOM

  if  [ -z "${esonly:-}" ]; then
    cat >> uninstall.sh <<- EOM
  echo "- docker.elastic.co/kibana/kibana:${es_version}"
EOM
  fi

  cat >> uninstall.sh <<- EOM
  if ask_confirmation; then
    if docker rmi "docker.elastic.co/elasticsearch/elasticsearch:${es_version}" >/dev/null 2>&amp;1; then
      echo "Image docker.elastic.co/elasticsearch/elasticsearch:${es_version} removed successfully"
    else
      echo "Failed to remove image docker.elastic.co/elasticsearch/elasticsearch:${es_version}. It might be in use."
    fi
EOM

  if  [ -z "${esonly:-}" ]; then
    cat >> uninstall.sh <<- EOM
    if docker rmi docker.elastic.co/kibana/kibana:${es_version} >/dev/null 2>&amp;1; then
      echo "Image docker.elastic.co/kibana/kibana:${es_version} removed successfully"
    else
      echo "Failed to remove image docker.elastic.co/kibana/kibana:${es_version}. It might be in use."
    fi
EOM
  fi

  cat >> uninstall.sh <<- EOM
  fi
  echo "Start-local successfully removed"
fi
EOM
  chmod +x uninstall.sh
}

create_docker_compose_file() {
  # Create the docker-compose-yml file
  cat > docker-compose.yml <<-&#39;EOM&#39;
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION}
    container_name: ${ES_LOCAL_CONTAINER_NAME}
    volumes:
      - dev-elasticsearch:/usr/share/elasticsearch/data
    ports:
      - 127.0.0.1:${ES_LOCAL_PORT}:9200
    environment:
      - discovery.type=single-node
      - ELASTIC_PASSWORD=${ES_LOCAL_PASSWORD}
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=false
      - xpack.license.self_generated.type=trial
      - xpack.ml.use_auto_machine_memory_percent=true
      - ES_JAVA_OPTS=-Xms${ES_LOCAL_HEAP_INIT} -Xmx${ES_LOCAL_HEAP_MAX}
      - cluster.routing.allocation.disk.watermark.low=${ES_LOCAL_DISK_SPACE_REQUIRED}
      - cluster.routing.allocation.disk.watermark.high=${ES_LOCAL_DISK_SPACE_REQUIRED}
      - cluster.routing.allocation.disk.watermark.flood_stage=${ES_LOCAL_DISK_SPACE_REQUIRED}
EOM
  
  # Fix for JDK AArch64 issue, see https://bugs.openjdk.org/browse/JDK-8345296
  if is_arm64; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
      - "_JAVA_OPTIONS=-XX:UseSVE=0"
EOM
  fi

  # Fix for OCI issue on LXC, see https://github.com/elastic/start-local/issues/27
  if ! detect_lxc; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
    ulimits:
      memlock:
        soft: -1
        hard: -1
EOM
  fi

  cat >> docker-compose.yml <<-&#39;EOM&#39;
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl --output /dev/null --silent --head --fail -u elastic:${ES_LOCAL_PASSWORD} http://elasticsearch:9200",
        ]
      interval: 10s
      timeout: 10s
      retries: 30

EOM

if  [ -z "${esonly:-}" ]; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
  kibana_settings:
    depends_on:
      elasticsearch:
        condition: service_healthy
    image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION}
    container_name: ${KIBANA_LOCAL_SETTINGS_CONTAINER_NAME}
    restart: &#39;no&#39;
    command: >
      bash -c &#39;
        echo "Setup the kibana_system password";
        start_time=$$(date +%s);
        timeout=60;
        until curl -s -u "elastic:${ES_LOCAL_PASSWORD}" -X POST http://elasticsearch:9200/_security/user/kibana_system/_password -d "{\"password\":\"${KIBANA_LOCAL_PASSWORD}\"}" -H "Content-Type: application/json" | grep -q "^{}"; do
          if [ $$(($$(date +%s) - $$start_time)) -ge $$timeout ]; then
            echo "Error: Elasticsearch timeout";
            exit 1;
          fi;
          sleep 2;
        done;
      &#39;

  kibana:
    depends_on:
      kibana_settings:
        condition: service_completed_successfully
    image: docker.elastic.co/kibana/kibana:${ES_LOCAL_VERSION}
    container_name: ${KIBANA_LOCAL_CONTAINER_NAME}
    volumes:
      - dev-kibana:/usr/share/kibana/data
      - ./config/telemetry.yml:/usr/share/kibana/config/telemetry.yml
    ports:
      - 127.0.0.1:${KIBANA_LOCAL_PORT}:5601
    environment:
      - SERVER_NAME=kibana
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_PASSWORD=${KIBANA_LOCAL_PASSWORD}
      - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${KIBANA_ENCRYPTION_KEY}
      - ELASTICSEARCH_PUBLICBASEURL=http://localhost:${ES_LOCAL_PORT}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s -I http://kibana:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;",
        ]
      interval: 10s
      timeout: 10s
      retries: 30

EOM
fi

  cat >> docker-compose.yml <<-&#39;EOM&#39;
volumes:
  dev-elasticsearch:
EOM

if  [ -z "${esonly:-}" ]; then
  cat >> docker-compose.yml <<-&#39;EOM&#39;
  dev-kibana:
EOM
fi

create_kibana_config
}

create_kibana_config() {
  if [ ! -d "config" ]; then
    mkdir config
  fi
  # Create telemetry
  cat > config/telemetry.yml <<- EOM
start-local:
  version: ${version}
EOM
}

print_steps() {
  if  [ -z "${esonly:-}" ]; then
    echo "âŒ›ï¸ Setting up Elasticsearch and Kibana v${es_version}..."
  else
    echo "âŒ›ï¸ Setting up Elasticsearch v${es_version}..."
  fi
  echo
  echo "- Generated random passwords"
  echo "- Created the ${folder} folder containing the files:"
  echo "  - .env, with settings"
  echo "  - docker-compose.yml, for Docker services"
  echo "  - start/stop/uninstall commands"
}

running_docker_compose() {
  # Execute docker compose
  echo "- Running ${docker}"
  echo
  set +e
  if ! $docker; then
    error_msg="Error: ${docker} command failed!"
    echo "$error_msg"
    if  [ -z "${esonly:-}" ]; then
      generate_error_log "${error_msg}" "${elasticsearch_container_name} ${kibana_container_name} kibana_settings"
    else
      generate_error_log "${error_msg}" "${elasticsearch_container_name}"
    fi
    cleanup
    exit 1
  fi
  set -e
}

api_key() {
  # Create an API key for Elasticsearch
  api_key=$(create_api_key "$es_password" "$api_key_name")
  if [ -n "$api_key" ]; then
    echo "ES_LOCAL_API_KEY=${api_key}" >> .env
  fi
}

kibana_wait() {
  if [ "$need_wait_for_kibana" = true ]; then
    wait_for_kibana 120
  fi
}

success() {
  echo
  if  [ -z "${esonly:-}" ]; then
    echo "ðŸŽ‰ Congrats, Elasticsearch and Kibana are installed and running in Docker!"
    echo
    echo "ðŸŒ Open your browser at http://localhost:5601"
    echo
    echo "   Username: elastic"
    echo "   Password: ${es_password}"
    echo
  else
    echo "ðŸŽ‰ Congrats, Elasticsearch is installed and running in Docker!"
  fi
  
  echo "ðŸ”Œ Elasticsearch API endpoint: http://localhost:9200"
  if [ -n "$api_key" ]; then
    echo "ðŸ”‘ API key: $api_key"
    echo
  else
    echo "ðŸ”‘ Use basic auth or create an API key"
    echo "https://www.elastic.co/guide/en/kibana/current/api-keys.html"
    echo
  fi
  echo
  echo "Learn more at https://github.com/elastic/start-local"

  echo
}

main() {
  parse_args "$@"
  startup
  check_requirements
  check_installation_folder
  check_docker_services
  create_installation_folder
  generate_passwords
  choose_es_version
  create_start_file
  create_stop_file
  create_uninstall_file
  create_env_file
  create_docker_compose_file
  print_steps
  running_docker_compose
  api_key
  kibana_wait
  success
}

ctrl_c() { 
  cleanup
  exit 1
}

# Trap ctrl-c
trap ctrl_c INT

# Execute the script
main "$@"
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heyuuuu77.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Elasticsearch","item":"https://heyuuuu77.github.io/posts/elasticsearch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Elasticsearch","name":"Elasticsearch","description":"start elasticsearch with docker localhost æ‰§è¡Œ\ncurl -fsSL https://elastic.co/start-local | sh 8DkwaOdk 8DkwaOdk elastic curl -ssSL will get start-local.sh. The content will be:\n#!/bin/sh # -------------------------------------------------------- # Run Elasticsearch and Kibana for local testing # Note: do not use this script in a production environment # -------------------------------------------------------- # # Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one # or more contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright # ownership. Elasticsearch B.V. licenses this file to you under # the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may # not use this file except in compliance with the License. # You may obtain a copy of the License at # #\thttp://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, # software distributed under the License is distributed on an # \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY # KIND, either express or implied. See the License for the # specific language governing permissions and limitations # under the License. set -eu parse_args() { # Parse the script parameters while [ \u0026#34;$#\u0026#34; -gt 0 ]; do case \u0026#34;$1\u0026#34; in -v) # Check that there is another argument for the version if [ $# -lt 2 ]; then echo \u0026#34;Error: -v requires a version value (eg. -v 8.17.0)\u0026#34; exit 1 fi es_version=\u0026#34;$2\u0026#34; shift 2 ;; --esonly) esonly=true shift ;; --) # End of options; shift and exit the loop shift break ;; -*) # Unknown or unsupported option echo \u0026#34;Error: Unknown option \u0026#39;$1\u0026#39;\u0026#34; exit 1 ;; *) # We\u0026#39;ve hit a non-option argument; stop parsing options break ;; esac done } startup() { echo echo \u0026#39; ______ _ _ _ \u0026#39; echo \u0026#39; | ____| | | | (_) \u0026#39; echo \u0026#39; | |__ | | __ _ ___| |_ _ ___ \u0026#39; echo \u0026#39; | __| | |/ _` / __| __| |/ __|\u0026#39; echo \u0026#39; | |____| | (_| \\__ \\ |_| | (__ \u0026#39; echo \u0026#39; |______|_|\\__,_|___/\\__|_|\\___|\u0026#39; echo \u0026#39;-------------------------------------------------\u0026#39; echo \u0026#39;ðŸš€ Run Elasticsearch and Kibana for local testing\u0026#39; echo \u0026#39;-------------------------------------------------\u0026#39; echo echo \u0026#39;â„¹ï¸ Do not use this script in a production environment\u0026#39; echo # Version version=\u0026#34;0.10.0\u0026#34; # Folder name for the installation installation_folder=\u0026#34;${ES_LOCAL_DIR:-elastic-start-local}\u0026#34; # API key name for Elasticsearch api_key_name=\u0026#34;elastic-start-local\u0026#34; # Name of the error log error_log=\u0026#34;error-start-local.log\u0026#34; # Minimum version for docker-compose min_docker_compose=\u0026#34;1.29.0\u0026#34; # Elasticsearch container name elasticsearch_container_name=\u0026#34;es-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}\u0026#34; # Kibana container name kibana_container_name=\u0026#34;kibana-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}\u0026#34; # Kibana settings container name kibana_settings_container_name=\u0026#34;kibana-local-settings${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}\u0026#34; # Minimum disk space required for docker images + services (in GB) min_disk_space_required=5 } # Check for ARM64 architecture is_arm64() { arch=\u0026#34;$(uname -m)\u0026#34; if [ \u0026#34;$arch\u0026#34; = \u0026#34;arm64\u0026#34; ] || [ \u0026#34;$arch\u0026#34; = \u0026#34;aarch64\u0026#34; ]; then return 0 # Return 0 (true) else return 1 # Return 1 (false) fi } # Alternative to sort -V, which is not available in BSD-based systems (e.g., macOS) version_sort() { awk -F\u0026#39;.\u0026#39; \u0026#39; { printf(\u0026#34;%d %d %d %s\\n\u0026#34;, $1, $2, $3, $0) }\u0026#39; | sort -n -k1,1 -k2,2 -k3,3 | awk \u0026#39;{print $4}\u0026#39; } # Function to check if the format is a valid semantic version (major.minor.patch) is_valid_version() { echo \u0026#34;$1\u0026#34; | grep -E -q \u0026#39;^[0-9]+\\.[0-9]+\\.[0-9]+$\u0026#39; } # Get the latest stable version of Elasticsearch # Note: It removes all the beta or candidate releases from the list # but includes the GA releases (e.g. new major) get_latest_version() { versions=\u0026#34;$(curl -s \u0026#34;https://artifacts.elastic.co/releases/stack.json\u0026#34;)\u0026#34; latest_version=$(echo \u0026#34;$versions\u0026#34; | awk -F\u0026#39;\u0026#34;\u0026#39; \u0026#39;/\u0026#34;version\u0026#34;: *\u0026#34;/ {print $4}\u0026#39; | grep -E \u0026#39;^[0-9]+\\.[0-9]+\\.[0-9]+( GA)?$\u0026#39; | version_sort | tail -n 1) # Remove the GA prefix from the version, if present latest_version=$(echo \u0026#34;$latest_version\u0026#34; | awk \u0026#39;{ gsub(/ GA$/, \u0026#34;\u0026#34;, $0); print }\u0026#39;) # Check if the latest version is empty if [ -z \u0026#34;$latest_version\u0026#34; ]; then echo \u0026#34;Error: the latest Elasticsearch version is empty\u0026#34; exit 1 fi # Check if the latest version is valid if ! is_valid_version \u0026#34;$latest_version\u0026#34;; then echo \u0026#34;Error: {$latest_version} is not a valid Elasticsearch stable version\u0026#34; exit 1 fi echo \u0026#34;$latest_version\u0026#34; } # Detect if running on LXC container detect_lxc() { # Check /proc/1/environ for LXC container identifier if grep -qa \u0026#34;container=lxc\u0026#34; /proc/1/environ 2\u0026gt;/dev/null; then return 0 fi # Check /proc/self/cgroup for LXC references if grep -q \u0026#34;lxc\u0026#34; /proc/self/cgroup 2\u0026gt;/dev/null; then return 0 fi # Check for LXC in /sys/fs/cgroup if grep -q \u0026#34;lxc\u0026#34; /sys/fs/cgroup/* 2\u0026gt;/dev/null; then return 0 fi # Use systemd-detect-virt if available if command -v systemd-detect-virt \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then if [ \u0026#34;$(systemd-detect-virt)\u0026#34; = \u0026#34;lxc\u0026#34; ]; then return 0 fi fi return 1 } # Get linux distribution get_os_info() { if [ -f /etc/os-release ]; then # Most modern Linux distributions have this file . /etc/os-release echo \u0026#34;Distribution: $NAME\u0026#34; echo \u0026#34;Version: $VERSION\u0026#34; elif [ -f /etc/lsb-release ]; then # For older distributions using LSB (Linux Standard Base) . /etc/lsb-release echo \u0026#34;Distribution: $DISTRIB_ID\u0026#34; echo \u0026#34;Version: $DISTRIB_RELEASE\u0026#34; elif [ -f /etc/debian_version ]; then # For Debian-based distributions without os-release or lsb-release echo \u0026#34;Distribution: Debian\u0026#34; echo \u0026#34;Version: $(cat /etc/debian_version)\u0026#34; elif [ -f /etc/redhat-release ]; then # For Red Hat-based distributions echo \u0026#34;Distribution: $(cat /etc/redhat-release)\u0026#34; elif [ -n \u0026#34;${OSTYPE+x}\u0026#34; ]; then if [ \u0026#34;${OSTYPE#darwin}\u0026#34; != \u0026#34;$OSTYPE\u0026#34; ]; then # macOS detection echo \u0026#34;Distribution: macOS\u0026#34; echo \u0026#34;Version: $(sw_vers -productVersion)\u0026#34; elif [ \u0026#34;$OSTYPE\u0026#34; = \u0026#34;cygwin\u0026#34; ] || [ \u0026#34;$OSTYPE\u0026#34; = \u0026#34;msys\u0026#34; ] || [ \u0026#34;$OSTYPE\u0026#34; = \u0026#34;win32\u0026#34; ]; then # Windows detection in environments like Git Bash, Cygwin, or MinGW echo \u0026#34;Distribution: Windows\u0026#34; echo \u0026#34;Version: $(cmd.exe /c ver | tr -d \u0026#39;\\r\u0026#39;)\u0026#34; elif [ \u0026#34;$OSTYPE\u0026#34; = \u0026#34;linux-gnu\u0026#34; ] \u0026amp;\u0026amp; uname -r | grep -q \u0026#34;Microsoft\u0026#34;; then # Windows Subsystem for Linux (WSL) detection echo \u0026#34;Distribution: Windows (WSL)\u0026#34; echo \u0026#34;Version: $(uname -r)\u0026#34; fi else echo \u0026#34;Unknown operating system\u0026#34; fi if [ -f /proc/version ]; then # Check if running on WSL2 or WSL1 for Microsoft if grep -q \u0026#34;WSL2\u0026#34; /proc/version; then echo \u0026#34;Running on WSL2\u0026#34; elif grep -q \u0026#34;microsoft\u0026#34; /proc/version; then echo \u0026#34;Running on WSL1\u0026#34; fi fi } # Check if a command exists available() { command -v \u0026#34;$1\u0026#34; \u0026gt;/dev/null; } # Revert the status, removing containers, volumes, network and folder cleanup() { if [ -d \u0026#34;./../$folder_to_clean\u0026#34; ]; then if [ -f \u0026#34;docker-compose.yml\u0026#34; ]; then $docker_clean \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 $docker_remove_volumes \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 fi cd .. rm -rf \u0026#34;${folder_to_clean}\u0026#34; fi } # Generate the error log # parameter 1: error message # parameter 2: the container names to retrieve, separated by comma generate_error_log() { msg=\u0026#34;$1\u0026#34; docker_services=\u0026#34;$2\u0026#34; error_file=\u0026#34;$error_log\u0026#34; if [ -d \u0026#34;./../$folder_to_clean\u0026#34; ]; then error_file=\u0026#34;./../$error_log\u0026#34; fi if [ -n \u0026#34;${msg}\u0026#34; ]; then echo \u0026#34;${msg}\u0026#34; \u0026gt; \u0026#34;$error_file\u0026#34; fi { echo \u0026#34;Start-local version: ${version}\u0026#34; echo \u0026#34;Docker engine: $(docker --version)\u0026#34; echo \u0026#34;Docker compose: ${docker_version}\u0026#34; get_os_info } \u0026gt;\u0026gt; \u0026#34;$error_file\u0026#34; for service in $docker_services; do echo \u0026#34;-- Logs of service ${service}:\u0026#34; \u0026gt;\u0026gt; \u0026#34;$error_file\u0026#34; docker logs \u0026#34;${service}\u0026#34; \u0026gt;\u0026gt; \u0026#34;$error_file\u0026#34; 2\u0026gt; /dev/null done echo \u0026#34;An error log has been generated in ${error_log} file.\u0026#34; echo \u0026#34;If you need assistance, open an issue at https://github.com/elastic/start-local/issues\u0026#34; } # Compare versions # parameter 1: version to compare # parameter 2: version to compare compare_versions() { v1=$1 v2=$2 original_ifs=\u0026#34;$IFS\u0026#34; IFS=\u0026#39;.\u0026#39; # shellcheck disable=SC2086 set -- $v1; v1_major=${1:-0}; v1_minor=${2:-0}; v1_patch=${3:-0} IFS=\u0026#39;.\u0026#39; # shellcheck disable=SC2086 set -- $v2; v2_major=${1:-0}; v2_minor=${2:-0}; v2_patch=${3:-0} IFS=\u0026#34;$original_ifs\u0026#34; [ \u0026#34;$v1_major\u0026#34; -lt \u0026#34;$v2_major\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;lt\u0026#34; \u0026amp;\u0026amp; return 0 [ \u0026#34;$v1_major\u0026#34; -gt \u0026#34;$v2_major\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;gt\u0026#34; \u0026amp;\u0026amp; return 0 [ \u0026#34;$v1_minor\u0026#34; -lt \u0026#34;$v2_minor\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;lt\u0026#34; \u0026amp;\u0026amp; return 0 [ \u0026#34;$v1_minor\u0026#34; -gt \u0026#34;$v2_minor\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;gt\u0026#34; \u0026amp;\u0026amp; return 0 [ \u0026#34;$v1_patch\u0026#34; -lt \u0026#34;$v2_patch\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;lt\u0026#34; \u0026amp;\u0026amp; return 0 [ \u0026#34;$v1_patch\u0026#34; -gt \u0026#34;$v2_patch\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;gt\u0026#34; \u0026amp;\u0026amp; return 0 echo \u0026#34;eq\u0026#34; } # Wait for availability of Kibana # parameter: timeout in seconds wait_for_kibana() { timeout=\u0026#34;${1:-60}\u0026#34; echo \u0026#34;- Waiting for Kibana to be ready\u0026#34; echo start_time=\u0026#34;$(date +%s)\u0026#34; until curl -s -I http://localhost:5601 | grep -q \u0026#39;HTTP/1.1 302 Found\u0026#39;; do elapsed_time=\u0026#34;$(($(date +%s) - start_time))\u0026#34; if [ \u0026#34;$elapsed_time\u0026#34; -ge \u0026#34;$timeout\u0026#34; ]; then error_msg=\u0026#34;Error: Kibana timeout of ${timeout} sec\u0026#34; echo \u0026#34;$error_msg\u0026#34; generate_error_log \u0026#34;${error_msg}\u0026#34; \u0026#34;${elasticsearch_container_name} ${kibana_container_name} kibana-settings\u0026#34; cleanup exit 1 fi sleep 2 done } # Generates a random password with letters and numbers # parameter: size of the password (default is 8 characters) random_password() { LENGTH=\u0026#34;${1:-8}\u0026#34; LC_ALL=C tr -dc \u0026#39;A-Za-z0-9\u0026#39; \u0026lt; /dev/urandom | head -c \u0026#34;${LENGTH}\u0026#34; } # Create an API key for Elasticsearch # parameter 1: the Elasticsearch password # parameter 2: name of the API key to generate create_api_key() { es_password=$1 name=$2 response=\u0026#34;$(curl -s -u \u0026#34;elastic:${es_password}\u0026#34; -X POST http://localhost:9200/_security/api_key -d \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;${name}\\\u0026#34;}\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34;)\u0026#34; if [ -z \u0026#34;$response\u0026#34; ]; then echo \u0026#34;\u0026#34; else api_key=\u0026#34;$(echo \u0026#34;$response\u0026#34; | grep -Eo \u0026#39;\u0026#34;encoded\u0026#34;:\u0026#34;[A-Za-z0-9+/=]+\u0026#39; | grep -Eo \u0026#39;[A-Za-z0-9+/=]+\u0026#39; | tail -n 1)\u0026#34; echo \u0026#34;$api_key\u0026#34; fi } # Check if a container is runnning # parameter: the name of the container check_container_running() { container_name=$1 containers=\u0026#34;$(docker ps --format \u0026#39;{{.Names}}\u0026#39;)\u0026#34; if echo \u0026#34;$containers\u0026#34; | grep -q \u0026#34;^${container_name}$\u0026#34;; then echo \u0026#34;The docker container \u0026#39;$container_name\u0026#39; is already running!\u0026#34; echo \u0026#34;You can have only one running at time.\u0026#34; echo \u0026#34;To stop the container run the following command:\u0026#34; echo echo \u0026#34;docker stop $container_name\u0026#34; exit 1 fi } # Check the available disk space in GB # parameter: required size in GB check_disk_space_gb() { required=$1 available_gb=$(($(df -k / | awk \u0026#39;NR==2 {print $4}\u0026#39;) / 1024 / 1024)) if [ \u0026#34;$available_gb\u0026#34; -lt \u0026#34;$required\u0026#34; ]; then echo \u0026#34;Error: only ${available_gb} GB of disk space available; ${required} GB required for the installation\u0026#34; exit 1 fi } check_requirements() { # Check the requirements check_disk_space_gb ${min_disk_space_required} if ! available \u0026#34;curl\u0026#34;; then echo \u0026#34;Error: curl command is required\u0026#34; echo \u0026#34;You can install it from https://curl.se/download.html.\u0026#34; exit 1 fi if ! available \u0026#34;grep\u0026#34;; then echo \u0026#34;Error: grep command is required\u0026#34; echo \u0026#34;You can install it from https://www.gnu.org/software/grep/.\u0026#34; exit 1 fi need_wait_for_kibana=true # Check for \u0026#34;docker compose\u0026#34; or \u0026#34;docker-compose\u0026#34; set +e if ! docker compose \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then if ! available \u0026#34;docker-compose\u0026#34;; then if ! available \u0026#34;docker\u0026#34;; then echo \u0026#34;Error: docker command is required\u0026#34; echo \u0026#34;You can install it from https://docs.docker.com/engine/install/.\u0026#34; exit 1 fi echo \u0026#34;Error: docker compose is required\u0026#34; echo \u0026#34;You can install it from https://docs.docker.com/compose/install/\u0026#34; exit 1 fi docker=\u0026#34;docker-compose up -d\u0026#34; docker_stop=\u0026#34;docker-compose stop\u0026#34; docker_clean=\u0026#34;docker-compose rm -fsv\u0026#34; docker_remove_volumes=\u0026#34;docker-compose down -v\u0026#34; docker_version=$(docker-compose --version | head -n 1 | grep -Eo \u0026#39;[0-9]+\\.[0-9]+\\.[0-9]+\u0026#39;) if [ \u0026#34;$(compare_versions \u0026#34;$docker_version\u0026#34; \u0026#34;$min_docker_compose\u0026#34;)\u0026#34; = \u0026#34;lt\u0026#34; ]; then echo \u0026#34;Unfortunately we don\u0026#39;t support docker compose ${docker_version}. The minimum required version is $min_docker_compose.\u0026#34; echo \u0026#34;You can migrate you docker compose from https://docs.docker.com/compose/migrate/\u0026#34; cleanup exit 1 fi else docker_stop=\u0026#34;docker compose stop\u0026#34; docker_clean=\u0026#34;docker compose rm -fsv\u0026#34; docker_remove_volumes=\u0026#34;docker compose down -v\u0026#34; docker_version=$(docker compose version | head -n 1 | grep -Eo \u0026#39;[0-9]+\\.[0-9]+\\.[0-9]+\u0026#39;) # --wait option has been introduced in 2.1.1+ if [ \u0026#34;$(compare_versions \u0026#34;$docker_version\u0026#34; \u0026#34;2.1.0\u0026#34;)\u0026#34; = \u0026#34;gt\u0026#34; ]; then docker=\u0026#34;docker compose up --wait\u0026#34; need_wait_for_kibana=false else docker=\u0026#34;docker compose up -d\u0026#34; fi fi set -e } check_installation_folder() { # Check if $installation_folder exists folder=$installation_folder if [ -d \u0026#34;$folder\u0026#34; ]; then if [ -n \u0026#34;$(ls -A \u0026#34;$folder\u0026#34;)\u0026#34; ]; then echo \u0026#34;It seems you have already a start-local installation in \u0026#39;${folder}\u0026#39;.\u0026#34; if [ -f \u0026#34;$folder/uninstall.sh\u0026#34; ]; then echo \u0026#34;I cannot proceed unless you uninstall it, using the following command:\u0026#34; echo \u0026#34;cd $folder \u0026amp;\u0026amp; ./uninstall.sh\u0026#34; else echo \u0026#34;I did not find the uninstall.sh file, you need to proceed manually.\u0026#34; if [ -f \u0026#34;$folder/docker-compose.yml\u0026#34; ] \u0026amp;\u0026amp; [ -f \u0026#34;$folder/.env\u0026#34; ]; then echo \u0026#34;Execute the following commands:\u0026#34; echo \u0026#34;cd $folder\u0026#34; echo \u0026#34;$docker_clean\u0026#34; echo \u0026#34;$docker_remove_volumes\u0026#34; echo \u0026#34;cd ..\u0026#34; echo \u0026#34;rm -rf $folder\u0026#34; fi fi exit 1 fi fi } check_docker_services() { # Check for docker containers running check_container_running \u0026#34;$elasticsearch_container_name\u0026#34; check_container_running \u0026#34;$kibana_container_name\u0026#34; check_container_running \u0026#34;$kibana_settings_container_name\u0026#34; } create_installation_folder() { # If $folder already exists, it is empty, see above if [ ! -d \u0026#34;$folder\u0026#34; ]; then mkdir \u0026#34;$folder\u0026#34; fi cd \u0026#34;$folder\u0026#34; folder_to_clean=$folder } generate_passwords() { # Generate random passwords es_password=\u0026#34;${ES_LOCAL_PASSWORD:-$(random_password)}\u0026#34; if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then kibana_password=\u0026#34;$(random_password)\u0026#34; kibana_encryption_key=\u0026#34;$(random_password 32)\u0026#34; fi } choose_es_version() { if [ -z \u0026#34;${es_version:-}\u0026#34; ]; then # Get the latest Elasticsearch version es_version=\u0026#34;$(get_latest_version)\u0026#34; fi # Fix for ARM64: add suffix \u0026#34;-arm64\u0026#34; if is_arm64 \u0026amp;\u0026amp; [ \u0026#34;${es_version##*-arm64}\u0026#34; = \u0026#34;$es_version\u0026#34; ]; then es_version=\u0026#34;${es_version}-arm64\u0026#34; fi } create_env_file() { # Create the .env file cat \u0026gt; .env \u0026lt;\u0026lt;- EOM START_LOCAL_VERSION=$version ES_LOCAL_VERSION=$es_version ES_LOCAL_CONTAINER_NAME=$elasticsearch_container_name ES_LOCAL_PASSWORD=$es_password ES_LOCAL_PORT=9200 ES_LOCAL_URL=http://localhost:\\${ES_LOCAL_PORT} ES_LOCAL_HEAP_INIT=128m ES_LOCAL_HEAP_MAX=2g ES_LOCAL_DISK_SPACE_REQUIRED=1gb EOM if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then cat \u0026gt;\u0026gt; .env \u0026lt;\u0026lt;- EOM KIBANA_LOCAL_CONTAINER_NAME=$kibana_container_name KIBANA_LOCAL_SETTINGS_CONTAINER_NAME=$kibana_settings_container_name KIBANA_LOCAL_PORT=5601 KIBANA_LOCAL_PASSWORD=$kibana_password KIBANA_ENCRYPTION_KEY=$kibana_encryption_key EOM fi } # Create the start script (start.sh) # including the license update if trial expired create_start_file() { today=$(date +%s) expire=$((today + 3600*24*30)) cat \u0026gt; start.sh \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; #!/bin/sh # Start script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR=\u0026#34;$(cd \u0026#34;$(dirname \u0026#34;$0\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd)\u0026#34; cd \u0026#34;${SCRIPT_DIR}\u0026#34; today=$(date +%s) . ./.env # Check disk space available_gb=$(($(df -k / | awk \u0026#39;NR==2 {print $4}\u0026#39;) / 1024 / 1024)) required=$(echo \u0026#34;${ES_LOCAL_DISK_SPACE_REQUIRED}\u0026#34; | grep -Eo \u0026#39;[0-9]+\u0026#39;) if [ \u0026#34;$available_gb\u0026#34; -lt \u0026#34;$required\u0026#34; ]; then echo \u0026#34;----------------------------------------------------------------------------\u0026#34; echo \u0026#34;WARNING: Disk space is below the ${required} GB limit. Elasticsearch will be\u0026#34; echo \u0026#34;executed in read-only mode. Please free up disk space to resolve this issue.\u0026#34; echo \u0026#34;----------------------------------------------------------------------------\u0026#34; echo \u0026#34;Press ENTER to confirm.\u0026#34; # shellcheck disable=SC2034 read -r line fi EOM if [ \u0026#34;$need_wait_for_kibana\u0026#34; = true ]; then cat \u0026gt;\u0026gt; start.sh \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; wait_for_kibana() { _timeout=\u0026#34;${1:-60}\u0026#34; echo \u0026#34;- Waiting for Kibana to be ready\u0026#34; echo _start_time=\u0026#34;$(date +%s)\u0026#34; until curl -s -I http://localhost:5601 | grep -q \u0026#39;HTTP/1.1 302 Found\u0026#39;; do elapsed_time=\u0026#34;$(($(date +%s) - _start_time))\u0026#34; if [ \u0026#34;$elapsed_time\u0026#34; -ge \u0026#34;$_timeout\u0026#34; ]; then echo \u0026#34;Error: Kibana timeout of ${_timeout} sec\u0026#34; exit 1 fi sleep 2 done } EOM fi cat \u0026gt;\u0026gt; start.sh \u0026lt;\u0026lt;- EOM if [ -z \u0026#34;\\${ES_LOCAL_LICENSE:-}\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;\\$today\u0026#34; -gt $expire ]; then echo \u0026#34;---------------------------------------------------------------------\u0026#34; echo \u0026#34;The one-month trial period has expired. You can continue using the\u0026#34; echo \u0026#34;Free and open Basic license or request to extend the trial for\u0026#34; echo \u0026#34;another 30 days using this form:\u0026#34; echo \u0026#34;https://www.elastic.co/trialextension\u0026#34; echo \u0026#34;---------------------------------------------------------------------\u0026#34; echo \u0026#34;For more info about the license: https://www.elastic.co/subscriptions\u0026#34; echo echo \u0026#34;Updating the license...\u0026#34; $docker elasticsearch \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 result=\\$(curl -s -X POST \u0026#34;\\${ES_LOCAL_URL}/_license/start_basic?acknowledge=true\u0026#34; -H \u0026#34;Authorization: ApiKey \\${ES_LOCAL_API_KEY}\u0026#34; -o /dev/null -w \u0026#39;%{http_code}\\n\u0026#39;) if [ \u0026#34;\\$result\u0026#34; = \u0026#34;200\u0026#34; ]; then echo \u0026#34;âœ… Basic license successfully installed\u0026#34; echo \u0026#34;ES_LOCAL_LICENSE=basic\u0026#34; \u0026gt;\u0026gt; .env else echo \u0026#34;Error: I cannot update the license\u0026#34; result=\\$(curl -s -X GET \u0026#34;\\${ES_LOCAL_URL}\u0026#34; -H \u0026#34;Authorization: ApiKey \\${ES_LOCAL_API_KEY}\u0026#34; -o /dev/null -w \u0026#39;%{http_code}\\n\u0026#39;) if [ \u0026#34;\\$result\u0026#34; != \u0026#34;200\u0026#34; ]; then echo \u0026#34;Elasticsearch is not running.\u0026#34; fi exit 1 fi echo fi $docker EOM if [ \u0026#34;$need_wait_for_kibana\u0026#34; = true ]; then cat \u0026gt;\u0026gt; start.sh \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; wait_for_kibana 120 EOM fi chmod +x start.sh } # Create the stop script (stop.sh) create_stop_file() { cat \u0026gt; stop.sh \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; #!/bin/sh # Stop script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR=\u0026#34;$(cd \u0026#34;$(dirname \u0026#34;$0\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd)\u0026#34; cd \u0026#34;${SCRIPT_DIR}\u0026#34; EOM cat \u0026gt;\u0026gt; stop.sh \u0026lt;\u0026lt;- EOM $docker_stop EOM chmod +x stop.sh } # Create the uninstall script (uninstall.sh) create_uninstall_file() { cat \u0026gt; uninstall.sh \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; #!/bin/sh # Uninstall script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR=\u0026#34;$(cd \u0026#34;$(dirname \u0026#34;$0\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd)\u0026#34; ask_confirmation() { echo \u0026#34;Do you confirm? (yes/no)\u0026#34; read -r answer case \u0026#34;$answer\u0026#34; in yes|y|Y|Yes|YES) return 0 # true ;; no|n|N|No|NO) return 1 # false ;; *) echo \u0026#34;Please answer yes or no.\u0026#34; ask_confirmation # Ask again if the input is invalid ;; esac } cd \u0026#34;${SCRIPT_DIR}\u0026#34; if [ ! -e \u0026#34;docker-compose.yml\u0026#34; ]; then echo \u0026#34;Error: I cannot find the docker-compose.yml file\u0026#34; echo \u0026#34;I cannot uninstall start-local.\u0026#34; fi if [ ! -e \u0026#34;.env\u0026#34; ]; then echo \u0026#34;Error: I cannot find the .env file\u0026#34; echo \u0026#34;I cannot uninstall start-local.\u0026#34; fi echo \u0026#34;This script will uninstall start-local.\u0026#34; echo \u0026#34;All data will be deleted and cannot be recovered.\u0026#34; if ask_confirmation; then EOM cat \u0026gt;\u0026gt; uninstall.sh \u0026lt;\u0026lt;- EOM $docker_clean $docker_remove_volumes rm docker-compose.yml .env uninstall.sh start.sh stop.sh config/telemetry.yml if [ -z \u0026#34;\\$(ls -A config)\u0026#34; ]; then rm -d config fi echo echo \u0026#34;Do you want to remove the following Docker images?\u0026#34; echo \u0026#34;- docker.elastic.co/elasticsearch/elasticsearch:${es_version}\u0026#34; EOM if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then cat \u0026gt;\u0026gt; uninstall.sh \u0026lt;\u0026lt;- EOM echo \u0026#34;- docker.elastic.co/kibana/kibana:${es_version}\u0026#34; EOM fi cat \u0026gt;\u0026gt; uninstall.sh \u0026lt;\u0026lt;- EOM if ask_confirmation; then if docker rmi \u0026#34;docker.elastic.co/elasticsearch/elasticsearch:${es_version}\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;Image docker.elastic.co/elasticsearch/elasticsearch:${es_version} removed successfully\u0026#34; else echo \u0026#34;Failed to remove image docker.elastic.co/elasticsearch/elasticsearch:${es_version}. It might be in use.\u0026#34; fi EOM if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then cat \u0026gt;\u0026gt; uninstall.sh \u0026lt;\u0026lt;- EOM if docker rmi docker.elastic.co/kibana/kibana:${es_version} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;Image docker.elastic.co/kibana/kibana:${es_version} removed successfully\u0026#34; else echo \u0026#34;Failed to remove image docker.elastic.co/kibana/kibana:${es_version}. It might be in use.\u0026#34; fi EOM fi cat \u0026gt;\u0026gt; uninstall.sh \u0026lt;\u0026lt;- EOM fi echo \u0026#34;Start-local successfully removed\u0026#34; fi EOM chmod +x uninstall.sh } create_docker_compose_file() { # Create the docker-compose-yml file cat \u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION} container_name: ${ES_LOCAL_CONTAINER_NAME} volumes: - dev-elasticsearch:/usr/share/elasticsearch/data ports: - 127.0.0.1:${ES_LOCAL_PORT}:9200 environment: - discovery.type=single-node - ELASTIC_PASSWORD=${ES_LOCAL_PASSWORD} - xpack.security.enabled=true - xpack.security.http.ssl.enabled=false - xpack.license.self_generated.type=trial - xpack.ml.use_auto_machine_memory_percent=true - ES_JAVA_OPTS=-Xms${ES_LOCAL_HEAP_INIT} -Xmx${ES_LOCAL_HEAP_MAX} - cluster.routing.allocation.disk.watermark.low=${ES_LOCAL_DISK_SPACE_REQUIRED} - cluster.routing.allocation.disk.watermark.high=${ES_LOCAL_DISK_SPACE_REQUIRED} - cluster.routing.allocation.disk.watermark.flood_stage=${ES_LOCAL_DISK_SPACE_REQUIRED} EOM # Fix for JDK AArch64 issue, see https://bugs.openjdk.org/browse/JDK-8345296 if is_arm64; then cat \u0026gt;\u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; - \u0026#34;_JAVA_OPTIONS=-XX:UseSVE=0\u0026#34; EOM fi # Fix for OCI issue on LXC, see https://github.com/elastic/start-local/issues/27 if ! detect_lxc; then cat \u0026gt;\u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; ulimits: memlock: soft: -1 hard: -1 EOM fi cat \u0026gt;\u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; healthcheck: test: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl --output /dev/null --silent --head --fail -u elastic:${ES_LOCAL_PASSWORD} http://elasticsearch:9200\u0026#34;, ] interval: 10s timeout: 10s retries: 30 EOM if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then cat \u0026gt;\u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; kibana_settings: depends_on: elasticsearch: condition: service_healthy image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION} container_name: ${KIBANA_LOCAL_SETTINGS_CONTAINER_NAME} restart: \u0026#39;no\u0026#39; command: \u0026gt; bash -c \u0026#39; echo \u0026#34;Setup the kibana_system password\u0026#34;; start_time=$$(date +%s); timeout=60; until curl -s -u \u0026#34;elastic:${ES_LOCAL_PASSWORD}\u0026#34; -X POST http://elasticsearch:9200/_security/user/kibana_system/_password -d \u0026#34;{\\\u0026#34;password\\\u0026#34;:\\\u0026#34;${KIBANA_LOCAL_PASSWORD}\\\u0026#34;}\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; | grep -q \u0026#34;^{}\u0026#34;; do if [ $$(($$(date +%s) - $$start_time)) -ge $$timeout ]; then echo \u0026#34;Error: Elasticsearch timeout\u0026#34;; exit 1; fi; sleep 2; done; \u0026#39; kibana: depends_on: kibana_settings: condition: service_completed_successfully image: docker.elastic.co/kibana/kibana:${ES_LOCAL_VERSION} container_name: ${KIBANA_LOCAL_CONTAINER_NAME} volumes: - dev-kibana:/usr/share/kibana/data - ./config/telemetry.yml:/usr/share/kibana/config/telemetry.yml ports: - 127.0.0.1:${KIBANA_LOCAL_PORT}:5601 environment: - SERVER_NAME=kibana - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=${KIBANA_LOCAL_PASSWORD} - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${KIBANA_ENCRYPTION_KEY} - ELASTICSEARCH_PUBLICBASEURL=http://localhost:${ES_LOCAL_PORT} healthcheck: test: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -s -I http://kibana:5601 | grep -q \u0026#39;HTTP/1.1 302 Found\u0026#39;\u0026#34;, ] interval: 10s timeout: 10s retries: 30 EOM fi cat \u0026gt;\u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; volumes: dev-elasticsearch: EOM if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then cat \u0026gt;\u0026gt; docker-compose.yml \u0026lt;\u0026lt;-\u0026#39;EOM\u0026#39; dev-kibana: EOM fi create_kibana_config } create_kibana_config() { if [ ! -d \u0026#34;config\u0026#34; ]; then mkdir config fi # Create telemetry cat \u0026gt; config/telemetry.yml \u0026lt;\u0026lt;- EOM start-local: version: ${version} EOM } print_steps() { if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then echo \u0026#34;âŒ›ï¸ Setting up Elasticsearch and Kibana v${es_version}...\u0026#34; else echo \u0026#34;âŒ›ï¸ Setting up Elasticsearch v${es_version}...\u0026#34; fi echo echo \u0026#34;- Generated random passwords\u0026#34; echo \u0026#34;- Created the ${folder} folder containing the files:\u0026#34; echo \u0026#34; - .env, with settings\u0026#34; echo \u0026#34; - docker-compose.yml, for Docker services\u0026#34; echo \u0026#34; - start/stop/uninstall commands\u0026#34; } running_docker_compose() { # Execute docker compose echo \u0026#34;- Running ${docker}\u0026#34; echo set +e if ! $docker; then error_msg=\u0026#34;Error: ${docker} command failed!\u0026#34; echo \u0026#34;$error_msg\u0026#34; if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then generate_error_log \u0026#34;${error_msg}\u0026#34; \u0026#34;${elasticsearch_container_name} ${kibana_container_name} kibana_settings\u0026#34; else generate_error_log \u0026#34;${error_msg}\u0026#34; \u0026#34;${elasticsearch_container_name}\u0026#34; fi cleanup exit 1 fi set -e } api_key() { # Create an API key for Elasticsearch api_key=$(create_api_key \u0026#34;$es_password\u0026#34; \u0026#34;$api_key_name\u0026#34;) if [ -n \u0026#34;$api_key\u0026#34; ]; then echo \u0026#34;ES_LOCAL_API_KEY=${api_key}\u0026#34; \u0026gt;\u0026gt; .env fi } kibana_wait() { if [ \u0026#34;$need_wait_for_kibana\u0026#34; = true ]; then wait_for_kibana 120 fi } success() { echo if [ -z \u0026#34;${esonly:-}\u0026#34; ]; then echo \u0026#34;ðŸŽ‰ Congrats, Elasticsearch and Kibana are installed and running in Docker!\u0026#34; echo echo \u0026#34;ðŸŒ Open your browser at http://localhost:5601\u0026#34; echo echo \u0026#34; Username: elastic\u0026#34; echo \u0026#34; Password: ${es_password}\u0026#34; echo else echo \u0026#34;ðŸŽ‰ Congrats, Elasticsearch is installed and running in Docker!\u0026#34; fi echo \u0026#34;ðŸ”Œ Elasticsearch API endpoint: http://localhost:9200\u0026#34; if [ -n \u0026#34;$api_key\u0026#34; ]; then echo \u0026#34;ðŸ”‘ API key: $api_key\u0026#34; echo else echo \u0026#34;ðŸ”‘ Use basic auth or create an API key\u0026#34; echo \u0026#34;https://www.elastic.co/guide/en/kibana/current/api-keys.html\u0026#34; echo fi echo echo \u0026#34;Learn more at https://github.com/elastic/start-local\u0026#34; echo } main() { parse_args \u0026#34;$@\u0026#34; startup check_requirements check_installation_folder check_docker_services create_installation_folder generate_passwords choose_es_version create_start_file create_stop_file create_uninstall_file create_env_file create_docker_compose_file print_steps running_docker_compose api_key kibana_wait success } ctrl_c() { cleanup exit 1 } # Trap ctrl-c trap ctrl_c INT # Execute the script main \u0026#34;$@\u0026#34; ","keywords":[],"articleBody":"start elasticsearch with docker localhost æ‰§è¡Œ\ncurl -fsSL https://elastic.co/start-local | sh 8DkwaOdk 8DkwaOdk elastic curl -ssSL will get start-local.sh. The content will be:\n#!/bin/sh # -------------------------------------------------------- # Run Elasticsearch and Kibana for local testing # Note: do not use this script in a production environment # -------------------------------------------------------- # # Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one # or more contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright # ownership. Elasticsearch B.V. licenses this file to you under # the Apache License, Version 2.0 (the \"License\"); you may # not use this file except in compliance with the License. # You may obtain a copy of the License at # #\thttp://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, # software distributed under the License is distributed on an # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY # KIND, either express or implied. See the License for the # specific language governing permissions and limitations # under the License. set -eu parse_args() { # Parse the script parameters while [ \"$#\" -gt 0 ]; do case \"$1\" in -v) # Check that there is another argument for the version if [ $# -lt 2 ]; then echo \"Error: -v requires a version value (eg. -v 8.17.0)\" exit 1 fi es_version=\"$2\" shift 2 ;; --esonly) esonly=true shift ;; --) # End of options; shift and exit the loop shift break ;; -*) # Unknown or unsupported option echo \"Error: Unknown option '$1'\" exit 1 ;; *) # We've hit a non-option argument; stop parsing options break ;; esac done } startup() { echo echo ' ______ _ _ _ ' echo ' | ____| | | | (_) ' echo ' | |__ | | __ _ ___| |_ _ ___ ' echo ' | __| | |/ _` / __| __| |/ __|' echo ' | |____| | (_| \\__ \\ |_| | (__ ' echo ' |______|_|\\__,_|___/\\__|_|\\___|' echo '-------------------------------------------------' echo 'ðŸš€ Run Elasticsearch and Kibana for local testing' echo '-------------------------------------------------' echo echo 'â„¹ï¸ Do not use this script in a production environment' echo # Version version=\"0.10.0\" # Folder name for the installation installation_folder=\"${ES_LOCAL_DIR:-elastic-start-local}\" # API key name for Elasticsearch api_key_name=\"elastic-start-local\" # Name of the error log error_log=\"error-start-local.log\" # Minimum version for docker-compose min_docker_compose=\"1.29.0\" # Elasticsearch container name elasticsearch_container_name=\"es-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}\" # Kibana container name kibana_container_name=\"kibana-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}\" # Kibana settings container name kibana_settings_container_name=\"kibana-local-settings${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}\" # Minimum disk space required for docker images + services (in GB) min_disk_space_required=5 } # Check for ARM64 architecture is_arm64() { arch=\"$(uname -m)\" if [ \"$arch\" = \"arm64\" ] || [ \"$arch\" = \"aarch64\" ]; then return 0 # Return 0 (true) else return 1 # Return 1 (false) fi } # Alternative to sort -V, which is not available in BSD-based systems (e.g., macOS) version_sort() { awk -F'.' ' { printf(\"%d %d %d %s\\n\", $1, $2, $3, $0) }' | sort -n -k1,1 -k2,2 -k3,3 | awk '{print $4}' } # Function to check if the format is a valid semantic version (major.minor.patch) is_valid_version() { echo \"$1\" | grep -E -q '^[0-9]+\\.[0-9]+\\.[0-9]+$' } # Get the latest stable version of Elasticsearch # Note: It removes all the beta or candidate releases from the list # but includes the GA releases (e.g. new major) get_latest_version() { versions=\"$(curl -s \"https://artifacts.elastic.co/releases/stack.json\")\" latest_version=$(echo \"$versions\" | awk -F'\"' '/\"version\": *\"/ {print $4}' | grep -E '^[0-9]+\\.[0-9]+\\.[0-9]+( GA)?$' | version_sort | tail -n 1) # Remove the GA prefix from the version, if present latest_version=$(echo \"$latest_version\" | awk '{ gsub(/ GA$/, \"\", $0); print }') # Check if the latest version is empty if [ -z \"$latest_version\" ]; then echo \"Error: the latest Elasticsearch version is empty\" exit 1 fi # Check if the latest version is valid if ! is_valid_version \"$latest_version\"; then echo \"Error: {$latest_version} is not a valid Elasticsearch stable version\" exit 1 fi echo \"$latest_version\" } # Detect if running on LXC container detect_lxc() { # Check /proc/1/environ for LXC container identifier if grep -qa \"container=lxc\" /proc/1/environ 2\u003e/dev/null; then return 0 fi # Check /proc/self/cgroup for LXC references if grep -q \"lxc\" /proc/self/cgroup 2\u003e/dev/null; then return 0 fi # Check for LXC in /sys/fs/cgroup if grep -q \"lxc\" /sys/fs/cgroup/* 2\u003e/dev/null; then return 0 fi # Use systemd-detect-virt if available if command -v systemd-detect-virt \u003e/dev/null 2\u003e\u00261; then if [ \"$(systemd-detect-virt)\" = \"lxc\" ]; then return 0 fi fi return 1 } # Get linux distribution get_os_info() { if [ -f /etc/os-release ]; then # Most modern Linux distributions have this file . /etc/os-release echo \"Distribution: $NAME\" echo \"Version: $VERSION\" elif [ -f /etc/lsb-release ]; then # For older distributions using LSB (Linux Standard Base) . /etc/lsb-release echo \"Distribution: $DISTRIB_ID\" echo \"Version: $DISTRIB_RELEASE\" elif [ -f /etc/debian_version ]; then # For Debian-based distributions without os-release or lsb-release echo \"Distribution: Debian\" echo \"Version: $(cat /etc/debian_version)\" elif [ -f /etc/redhat-release ]; then # For Red Hat-based distributions echo \"Distribution: $(cat /etc/redhat-release)\" elif [ -n \"${OSTYPE+x}\" ]; then if [ \"${OSTYPE#darwin}\" != \"$OSTYPE\" ]; then # macOS detection echo \"Distribution: macOS\" echo \"Version: $(sw_vers -productVersion)\" elif [ \"$OSTYPE\" = \"cygwin\" ] || [ \"$OSTYPE\" = \"msys\" ] || [ \"$OSTYPE\" = \"win32\" ]; then # Windows detection in environments like Git Bash, Cygwin, or MinGW echo \"Distribution: Windows\" echo \"Version: $(cmd.exe /c ver | tr -d '\\r')\" elif [ \"$OSTYPE\" = \"linux-gnu\" ] \u0026\u0026 uname -r | grep -q \"Microsoft\"; then # Windows Subsystem for Linux (WSL) detection echo \"Distribution: Windows (WSL)\" echo \"Version: $(uname -r)\" fi else echo \"Unknown operating system\" fi if [ -f /proc/version ]; then # Check if running on WSL2 or WSL1 for Microsoft if grep -q \"WSL2\" /proc/version; then echo \"Running on WSL2\" elif grep -q \"microsoft\" /proc/version; then echo \"Running on WSL1\" fi fi } # Check if a command exists available() { command -v \"$1\" \u003e/dev/null; } # Revert the status, removing containers, volumes, network and folder cleanup() { if [ -d \"./../$folder_to_clean\" ]; then if [ -f \"docker-compose.yml\" ]; then $docker_clean \u003e/dev/null 2\u003e\u00261 $docker_remove_volumes \u003e/dev/null 2\u003e\u00261 fi cd .. rm -rf \"${folder_to_clean}\" fi } # Generate the error log # parameter 1: error message # parameter 2: the container names to retrieve, separated by comma generate_error_log() { msg=\"$1\" docker_services=\"$2\" error_file=\"$error_log\" if [ -d \"./../$folder_to_clean\" ]; then error_file=\"./../$error_log\" fi if [ -n \"${msg}\" ]; then echo \"${msg}\" \u003e \"$error_file\" fi { echo \"Start-local version: ${version}\" echo \"Docker engine: $(docker --version)\" echo \"Docker compose: ${docker_version}\" get_os_info } \u003e\u003e \"$error_file\" for service in $docker_services; do echo \"-- Logs of service ${service}:\" \u003e\u003e \"$error_file\" docker logs \"${service}\" \u003e\u003e \"$error_file\" 2\u003e /dev/null done echo \"An error log has been generated in ${error_log} file.\" echo \"If you need assistance, open an issue at https://github.com/elastic/start-local/issues\" } # Compare versions # parameter 1: version to compare # parameter 2: version to compare compare_versions() { v1=$1 v2=$2 original_ifs=\"$IFS\" IFS='.' # shellcheck disable=SC2086 set -- $v1; v1_major=${1:-0}; v1_minor=${2:-0}; v1_patch=${3:-0} IFS='.' # shellcheck disable=SC2086 set -- $v2; v2_major=${1:-0}; v2_minor=${2:-0}; v2_patch=${3:-0} IFS=\"$original_ifs\" [ \"$v1_major\" -lt \"$v2_major\" ] \u0026\u0026 echo \"lt\" \u0026\u0026 return 0 [ \"$v1_major\" -gt \"$v2_major\" ] \u0026\u0026 echo \"gt\" \u0026\u0026 return 0 [ \"$v1_minor\" -lt \"$v2_minor\" ] \u0026\u0026 echo \"lt\" \u0026\u0026 return 0 [ \"$v1_minor\" -gt \"$v2_minor\" ] \u0026\u0026 echo \"gt\" \u0026\u0026 return 0 [ \"$v1_patch\" -lt \"$v2_patch\" ] \u0026\u0026 echo \"lt\" \u0026\u0026 return 0 [ \"$v1_patch\" -gt \"$v2_patch\" ] \u0026\u0026 echo \"gt\" \u0026\u0026 return 0 echo \"eq\" } # Wait for availability of Kibana # parameter: timeout in seconds wait_for_kibana() { timeout=\"${1:-60}\" echo \"- Waiting for Kibana to be ready\" echo start_time=\"$(date +%s)\" until curl -s -I http://localhost:5601 | grep -q 'HTTP/1.1 302 Found'; do elapsed_time=\"$(($(date +%s) - start_time))\" if [ \"$elapsed_time\" -ge \"$timeout\" ]; then error_msg=\"Error: Kibana timeout of ${timeout} sec\" echo \"$error_msg\" generate_error_log \"${error_msg}\" \"${elasticsearch_container_name} ${kibana_container_name} kibana-settings\" cleanup exit 1 fi sleep 2 done } # Generates a random password with letters and numbers # parameter: size of the password (default is 8 characters) random_password() { LENGTH=\"${1:-8}\" LC_ALL=C tr -dc 'A-Za-z0-9' \u003c /dev/urandom | head -c \"${LENGTH}\" } # Create an API key for Elasticsearch # parameter 1: the Elasticsearch password # parameter 2: name of the API key to generate create_api_key() { es_password=$1 name=$2 response=\"$(curl -s -u \"elastic:${es_password}\" -X POST http://localhost:9200/_security/api_key -d \"{\\\"name\\\": \\\"${name}\\\"}\" -H \"Content-Type: application/json\")\" if [ -z \"$response\" ]; then echo \"\" else api_key=\"$(echo \"$response\" | grep -Eo '\"encoded\":\"[A-Za-z0-9+/=]+' | grep -Eo '[A-Za-z0-9+/=]+' | tail -n 1)\" echo \"$api_key\" fi } # Check if a container is runnning # parameter: the name of the container check_container_running() { container_name=$1 containers=\"$(docker ps --format '{{.Names}}')\" if echo \"$containers\" | grep -q \"^${container_name}$\"; then echo \"The docker container '$container_name' is already running!\" echo \"You can have only one running at time.\" echo \"To stop the container run the following command:\" echo echo \"docker stop $container_name\" exit 1 fi } # Check the available disk space in GB # parameter: required size in GB check_disk_space_gb() { required=$1 available_gb=$(($(df -k / | awk 'NR==2 {print $4}') / 1024 / 1024)) if [ \"$available_gb\" -lt \"$required\" ]; then echo \"Error: only ${available_gb} GB of disk space available; ${required} GB required for the installation\" exit 1 fi } check_requirements() { # Check the requirements check_disk_space_gb ${min_disk_space_required} if ! available \"curl\"; then echo \"Error: curl command is required\" echo \"You can install it from https://curl.se/download.html.\" exit 1 fi if ! available \"grep\"; then echo \"Error: grep command is required\" echo \"You can install it from https://www.gnu.org/software/grep/.\" exit 1 fi need_wait_for_kibana=true # Check for \"docker compose\" or \"docker-compose\" set +e if ! docker compose \u003e/dev/null 2\u003e\u00261; then if ! available \"docker-compose\"; then if ! available \"docker\"; then echo \"Error: docker command is required\" echo \"You can install it from https://docs.docker.com/engine/install/.\" exit 1 fi echo \"Error: docker compose is required\" echo \"You can install it from https://docs.docker.com/compose/install/\" exit 1 fi docker=\"docker-compose up -d\" docker_stop=\"docker-compose stop\" docker_clean=\"docker-compose rm -fsv\" docker_remove_volumes=\"docker-compose down -v\" docker_version=$(docker-compose --version | head -n 1 | grep -Eo '[0-9]+\\.[0-9]+\\.[0-9]+') if [ \"$(compare_versions \"$docker_version\" \"$min_docker_compose\")\" = \"lt\" ]; then echo \"Unfortunately we don't support docker compose ${docker_version}. The minimum required version is $min_docker_compose.\" echo \"You can migrate you docker compose from https://docs.docker.com/compose/migrate/\" cleanup exit 1 fi else docker_stop=\"docker compose stop\" docker_clean=\"docker compose rm -fsv\" docker_remove_volumes=\"docker compose down -v\" docker_version=$(docker compose version | head -n 1 | grep -Eo '[0-9]+\\.[0-9]+\\.[0-9]+') # --wait option has been introduced in 2.1.1+ if [ \"$(compare_versions \"$docker_version\" \"2.1.0\")\" = \"gt\" ]; then docker=\"docker compose up --wait\" need_wait_for_kibana=false else docker=\"docker compose up -d\" fi fi set -e } check_installation_folder() { # Check if $installation_folder exists folder=$installation_folder if [ -d \"$folder\" ]; then if [ -n \"$(ls -A \"$folder\")\" ]; then echo \"It seems you have already a start-local installation in '${folder}'.\" if [ -f \"$folder/uninstall.sh\" ]; then echo \"I cannot proceed unless you uninstall it, using the following command:\" echo \"cd $folder \u0026\u0026 ./uninstall.sh\" else echo \"I did not find the uninstall.sh file, you need to proceed manually.\" if [ -f \"$folder/docker-compose.yml\" ] \u0026\u0026 [ -f \"$folder/.env\" ]; then echo \"Execute the following commands:\" echo \"cd $folder\" echo \"$docker_clean\" echo \"$docker_remove_volumes\" echo \"cd ..\" echo \"rm -rf $folder\" fi fi exit 1 fi fi } check_docker_services() { # Check for docker containers running check_container_running \"$elasticsearch_container_name\" check_container_running \"$kibana_container_name\" check_container_running \"$kibana_settings_container_name\" } create_installation_folder() { # If $folder already exists, it is empty, see above if [ ! -d \"$folder\" ]; then mkdir \"$folder\" fi cd \"$folder\" folder_to_clean=$folder } generate_passwords() { # Generate random passwords es_password=\"${ES_LOCAL_PASSWORD:-$(random_password)}\" if [ -z \"${esonly:-}\" ]; then kibana_password=\"$(random_password)\" kibana_encryption_key=\"$(random_password 32)\" fi } choose_es_version() { if [ -z \"${es_version:-}\" ]; then # Get the latest Elasticsearch version es_version=\"$(get_latest_version)\" fi # Fix for ARM64: add suffix \"-arm64\" if is_arm64 \u0026\u0026 [ \"${es_version##*-arm64}\" = \"$es_version\" ]; then es_version=\"${es_version}-arm64\" fi } create_env_file() { # Create the .env file cat \u003e .env \u003c\u003c- EOM START_LOCAL_VERSION=$version ES_LOCAL_VERSION=$es_version ES_LOCAL_CONTAINER_NAME=$elasticsearch_container_name ES_LOCAL_PASSWORD=$es_password ES_LOCAL_PORT=9200 ES_LOCAL_URL=http://localhost:\\${ES_LOCAL_PORT} ES_LOCAL_HEAP_INIT=128m ES_LOCAL_HEAP_MAX=2g ES_LOCAL_DISK_SPACE_REQUIRED=1gb EOM if [ -z \"${esonly:-}\" ]; then cat \u003e\u003e .env \u003c\u003c- EOM KIBANA_LOCAL_CONTAINER_NAME=$kibana_container_name KIBANA_LOCAL_SETTINGS_CONTAINER_NAME=$kibana_settings_container_name KIBANA_LOCAL_PORT=5601 KIBANA_LOCAL_PASSWORD=$kibana_password KIBANA_ENCRYPTION_KEY=$kibana_encryption_key EOM fi } # Create the start script (start.sh) # including the license update if trial expired create_start_file() { today=$(date +%s) expire=$((today + 3600*24*30)) cat \u003e start.sh \u003c\u003c-'EOM' #!/bin/sh # Start script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" \u0026\u0026 pwd)\" cd \"${SCRIPT_DIR}\" today=$(date +%s) . ./.env # Check disk space available_gb=$(($(df -k / | awk 'NR==2 {print $4}') / 1024 / 1024)) required=$(echo \"${ES_LOCAL_DISK_SPACE_REQUIRED}\" | grep -Eo '[0-9]+') if [ \"$available_gb\" -lt \"$required\" ]; then echo \"----------------------------------------------------------------------------\" echo \"WARNING: Disk space is below the ${required} GB limit. Elasticsearch will be\" echo \"executed in read-only mode. Please free up disk space to resolve this issue.\" echo \"----------------------------------------------------------------------------\" echo \"Press ENTER to confirm.\" # shellcheck disable=SC2034 read -r line fi EOM if [ \"$need_wait_for_kibana\" = true ]; then cat \u003e\u003e start.sh \u003c\u003c-'EOM' wait_for_kibana() { _timeout=\"${1:-60}\" echo \"- Waiting for Kibana to be ready\" echo _start_time=\"$(date +%s)\" until curl -s -I http://localhost:5601 | grep -q 'HTTP/1.1 302 Found'; do elapsed_time=\"$(($(date +%s) - _start_time))\" if [ \"$elapsed_time\" -ge \"$_timeout\" ]; then echo \"Error: Kibana timeout of ${_timeout} sec\" exit 1 fi sleep 2 done } EOM fi cat \u003e\u003e start.sh \u003c\u003c- EOM if [ -z \"\\${ES_LOCAL_LICENSE:-}\" ] \u0026\u0026 [ \"\\$today\" -gt $expire ]; then echo \"---------------------------------------------------------------------\" echo \"The one-month trial period has expired. You can continue using the\" echo \"Free and open Basic license or request to extend the trial for\" echo \"another 30 days using this form:\" echo \"https://www.elastic.co/trialextension\" echo \"---------------------------------------------------------------------\" echo \"For more info about the license: https://www.elastic.co/subscriptions\" echo echo \"Updating the license...\" $docker elasticsearch \u003e/dev/null 2\u003e\u00261 result=\\$(curl -s -X POST \"\\${ES_LOCAL_URL}/_license/start_basic?acknowledge=true\" -H \"Authorization: ApiKey \\${ES_LOCAL_API_KEY}\" -o /dev/null -w '%{http_code}\\n') if [ \"\\$result\" = \"200\" ]; then echo \"âœ… Basic license successfully installed\" echo \"ES_LOCAL_LICENSE=basic\" \u003e\u003e .env else echo \"Error: I cannot update the license\" result=\\$(curl -s -X GET \"\\${ES_LOCAL_URL}\" -H \"Authorization: ApiKey \\${ES_LOCAL_API_KEY}\" -o /dev/null -w '%{http_code}\\n') if [ \"\\$result\" != \"200\" ]; then echo \"Elasticsearch is not running.\" fi exit 1 fi echo fi $docker EOM if [ \"$need_wait_for_kibana\" = true ]; then cat \u003e\u003e start.sh \u003c\u003c-'EOM' wait_for_kibana 120 EOM fi chmod +x start.sh } # Create the stop script (stop.sh) create_stop_file() { cat \u003e stop.sh \u003c\u003c-'EOM' #!/bin/sh # Stop script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" \u0026\u0026 pwd)\" cd \"${SCRIPT_DIR}\" EOM cat \u003e\u003e stop.sh \u003c\u003c- EOM $docker_stop EOM chmod +x stop.sh } # Create the uninstall script (uninstall.sh) create_uninstall_file() { cat \u003e uninstall.sh \u003c\u003c-'EOM' #!/bin/sh # Uninstall script for start-local # More information: https://github.com/elastic/start-local set -eu SCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" \u0026\u0026 pwd)\" ask_confirmation() { echo \"Do you confirm? (yes/no)\" read -r answer case \"$answer\" in yes|y|Y|Yes|YES) return 0 # true ;; no|n|N|No|NO) return 1 # false ;; *) echo \"Please answer yes or no.\" ask_confirmation # Ask again if the input is invalid ;; esac } cd \"${SCRIPT_DIR}\" if [ ! -e \"docker-compose.yml\" ]; then echo \"Error: I cannot find the docker-compose.yml file\" echo \"I cannot uninstall start-local.\" fi if [ ! -e \".env\" ]; then echo \"Error: I cannot find the .env file\" echo \"I cannot uninstall start-local.\" fi echo \"This script will uninstall start-local.\" echo \"All data will be deleted and cannot be recovered.\" if ask_confirmation; then EOM cat \u003e\u003e uninstall.sh \u003c\u003c- EOM $docker_clean $docker_remove_volumes rm docker-compose.yml .env uninstall.sh start.sh stop.sh config/telemetry.yml if [ -z \"\\$(ls -A config)\" ]; then rm -d config fi echo echo \"Do you want to remove the following Docker images?\" echo \"- docker.elastic.co/elasticsearch/elasticsearch:${es_version}\" EOM if [ -z \"${esonly:-}\" ]; then cat \u003e\u003e uninstall.sh \u003c\u003c- EOM echo \"- docker.elastic.co/kibana/kibana:${es_version}\" EOM fi cat \u003e\u003e uninstall.sh \u003c\u003c- EOM if ask_confirmation; then if docker rmi \"docker.elastic.co/elasticsearch/elasticsearch:${es_version}\" \u003e/dev/null 2\u003e\u00261; then echo \"Image docker.elastic.co/elasticsearch/elasticsearch:${es_version} removed successfully\" else echo \"Failed to remove image docker.elastic.co/elasticsearch/elasticsearch:${es_version}. It might be in use.\" fi EOM if [ -z \"${esonly:-}\" ]; then cat \u003e\u003e uninstall.sh \u003c\u003c- EOM if docker rmi docker.elastic.co/kibana/kibana:${es_version} \u003e/dev/null 2\u003e\u00261; then echo \"Image docker.elastic.co/kibana/kibana:${es_version} removed successfully\" else echo \"Failed to remove image docker.elastic.co/kibana/kibana:${es_version}. It might be in use.\" fi EOM fi cat \u003e\u003e uninstall.sh \u003c\u003c- EOM fi echo \"Start-local successfully removed\" fi EOM chmod +x uninstall.sh } create_docker_compose_file() { # Create the docker-compose-yml file cat \u003e docker-compose.yml \u003c\u003c-'EOM' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION} container_name: ${ES_LOCAL_CONTAINER_NAME} volumes: - dev-elasticsearch:/usr/share/elasticsearch/data ports: - 127.0.0.1:${ES_LOCAL_PORT}:9200 environment: - discovery.type=single-node - ELASTIC_PASSWORD=${ES_LOCAL_PASSWORD} - xpack.security.enabled=true - xpack.security.http.ssl.enabled=false - xpack.license.self_generated.type=trial - xpack.ml.use_auto_machine_memory_percent=true - ES_JAVA_OPTS=-Xms${ES_LOCAL_HEAP_INIT} -Xmx${ES_LOCAL_HEAP_MAX} - cluster.routing.allocation.disk.watermark.low=${ES_LOCAL_DISK_SPACE_REQUIRED} - cluster.routing.allocation.disk.watermark.high=${ES_LOCAL_DISK_SPACE_REQUIRED} - cluster.routing.allocation.disk.watermark.flood_stage=${ES_LOCAL_DISK_SPACE_REQUIRED} EOM # Fix for JDK AArch64 issue, see https://bugs.openjdk.org/browse/JDK-8345296 if is_arm64; then cat \u003e\u003e docker-compose.yml \u003c\u003c-'EOM' - \"_JAVA_OPTIONS=-XX:UseSVE=0\" EOM fi # Fix for OCI issue on LXC, see https://github.com/elastic/start-local/issues/27 if ! detect_lxc; then cat \u003e\u003e docker-compose.yml \u003c\u003c-'EOM' ulimits: memlock: soft: -1 hard: -1 EOM fi cat \u003e\u003e docker-compose.yml \u003c\u003c-'EOM' healthcheck: test: [ \"CMD-SHELL\", \"curl --output /dev/null --silent --head --fail -u elastic:${ES_LOCAL_PASSWORD} http://elasticsearch:9200\", ] interval: 10s timeout: 10s retries: 30 EOM if [ -z \"${esonly:-}\" ]; then cat \u003e\u003e docker-compose.yml \u003c\u003c-'EOM' kibana_settings: depends_on: elasticsearch: condition: service_healthy image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION} container_name: ${KIBANA_LOCAL_SETTINGS_CONTAINER_NAME} restart: 'no' command: \u003e bash -c ' echo \"Setup the kibana_system password\"; start_time=$$(date +%s); timeout=60; until curl -s -u \"elastic:${ES_LOCAL_PASSWORD}\" -X POST http://elasticsearch:9200/_security/user/kibana_system/_password -d \"{\\\"password\\\":\\\"${KIBANA_LOCAL_PASSWORD}\\\"}\" -H \"Content-Type: application/json\" | grep -q \"^{}\"; do if [ $$(($$(date +%s) - $$start_time)) -ge $$timeout ]; then echo \"Error: Elasticsearch timeout\"; exit 1; fi; sleep 2; done; ' kibana: depends_on: kibana_settings: condition: service_completed_successfully image: docker.elastic.co/kibana/kibana:${ES_LOCAL_VERSION} container_name: ${KIBANA_LOCAL_CONTAINER_NAME} volumes: - dev-kibana:/usr/share/kibana/data - ./config/telemetry.yml:/usr/share/kibana/config/telemetry.yml ports: - 127.0.0.1:${KIBANA_LOCAL_PORT}:5601 environment: - SERVER_NAME=kibana - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - ELASTICSEARCH_USERNAME=kibana_system - ELASTICSEARCH_PASSWORD=${KIBANA_LOCAL_PASSWORD} - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${KIBANA_ENCRYPTION_KEY} - ELASTICSEARCH_PUBLICBASEURL=http://localhost:${ES_LOCAL_PORT} healthcheck: test: [ \"CMD-SHELL\", \"curl -s -I http://kibana:5601 | grep -q 'HTTP/1.1 302 Found'\", ] interval: 10s timeout: 10s retries: 30 EOM fi cat \u003e\u003e docker-compose.yml \u003c\u003c-'EOM' volumes: dev-elasticsearch: EOM if [ -z \"${esonly:-}\" ]; then cat \u003e\u003e docker-compose.yml \u003c\u003c-'EOM' dev-kibana: EOM fi create_kibana_config } create_kibana_config() { if [ ! -d \"config\" ]; then mkdir config fi # Create telemetry cat \u003e config/telemetry.yml \u003c\u003c- EOM start-local: version: ${version} EOM } print_steps() { if [ -z \"${esonly:-}\" ]; then echo \"âŒ›ï¸ Setting up Elasticsearch and Kibana v${es_version}...\" else echo \"âŒ›ï¸ Setting up Elasticsearch v${es_version}...\" fi echo echo \"- Generated random passwords\" echo \"- Created the ${folder} folder containing the files:\" echo \" - .env, with settings\" echo \" - docker-compose.yml, for Docker services\" echo \" - start/stop/uninstall commands\" } running_docker_compose() { # Execute docker compose echo \"- Running ${docker}\" echo set +e if ! $docker; then error_msg=\"Error: ${docker} command failed!\" echo \"$error_msg\" if [ -z \"${esonly:-}\" ]; then generate_error_log \"${error_msg}\" \"${elasticsearch_container_name} ${kibana_container_name} kibana_settings\" else generate_error_log \"${error_msg}\" \"${elasticsearch_container_name}\" fi cleanup exit 1 fi set -e } api_key() { # Create an API key for Elasticsearch api_key=$(create_api_key \"$es_password\" \"$api_key_name\") if [ -n \"$api_key\" ]; then echo \"ES_LOCAL_API_KEY=${api_key}\" \u003e\u003e .env fi } kibana_wait() { if [ \"$need_wait_for_kibana\" = true ]; then wait_for_kibana 120 fi } success() { echo if [ -z \"${esonly:-}\" ]; then echo \"ðŸŽ‰ Congrats, Elasticsearch and Kibana are installed and running in Docker!\" echo echo \"ðŸŒ Open your browser at http://localhost:5601\" echo echo \" Username: elastic\" echo \" Password: ${es_password}\" echo else echo \"ðŸŽ‰ Congrats, Elasticsearch is installed and running in Docker!\" fi echo \"ðŸ”Œ Elasticsearch API endpoint: http://localhost:9200\" if [ -n \"$api_key\" ]; then echo \"ðŸ”‘ API key: $api_key\" echo else echo \"ðŸ”‘ Use basic auth or create an API key\" echo \"https://www.elastic.co/guide/en/kibana/current/api-keys.html\" echo fi echo echo \"Learn more at https://github.com/elastic/start-local\" echo } main() { parse_args \"$@\" startup check_requirements check_installation_folder check_docker_services create_installation_folder generate_passwords choose_es_version create_start_file create_stop_file create_uninstall_file create_env_file create_docker_compose_file print_steps running_docker_compose api_key kibana_wait success } ctrl_c() { cleanup exit 1 } # Trap ctrl-c trap ctrl_c INT # Execute the script main \"$@\" ","wordCount":"3213","inLanguage":"en","image":"https://heyuuuu77.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-07-30T20:06:04+08:00","dateModified":"2025-07-30T20:06:04+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://heyuuuu77.github.io/posts/elasticsearch/"},"publisher":{"@type":"Organization","name":"heyuuuu77","logo":{"@type":"ImageObject","url":"https://heyuuuu77.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heyuuuu77.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://heyuuuu77.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://heyuuuu77.github.io/categories title=categories><span>categories</span></a></li><li><a href=https://heyuuuu77.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://heyuuuu77.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://heyuuuu77.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://heyuuuu77.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Elasticsearch</h1><div class=post-meta><span title='2025-07-30 20:06:04 +0800 CST'>July 30, 2025</span>&nbsp;Â·&nbsp;16 min&nbsp;Â·&nbsp;3213 words&nbsp;Â·&nbsp;Me</div><hr><ul class=post-tags></ul></header><div class=post-content><h3 id=start-elasticsearch-with-docker-localhost>start elasticsearch with docker localhost<a hidden class=anchor aria-hidden=true href=#start-elasticsearch-with-docker-localhost>#</a></h3><p>æ‰§è¡Œ</p><pre tabindex=0><code>curl -fsSL https://elastic.co/start-local | sh 8DkwaOdk 8DkwaOdk elastic
</code></pre><p>curl -ssSL will get start-local.sh. The content will be:</p><pre tabindex=0><code>
#!/bin/sh
# --------------------------------------------------------
# Run Elasticsearch and Kibana for local testing
# Note: do not use this script in a production environment
# --------------------------------------------------------
#
# Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
# or more contributor license agreements. See the NOTICE file distributed with
# this work for additional information regarding copyright
# ownership. Elasticsearch B.V. licenses this file to you under
# the Apache License, Version 2.0 (the &#34;License&#34;); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
set -eu

parse_args() {
  # Parse the script parameters
  while [ &#34;$#&#34; -gt 0 ]; do
    case &#34;$1&#34; in
      -v)
        # Check that there is another argument for the version
        if [ $# -lt 2 ]; then
          echo &#34;Error: -v requires a version value (eg. -v 8.17.0)&#34;
          exit 1
        fi
        es_version=&#34;$2&#34;
        shift 2
        ;;

      --esonly)
        esonly=true
        shift
        ;;

      --)
        # End of options; shift and exit the loop
        shift
        break
        ;;

      -*)
        # Unknown or unsupported option
        echo &#34;Error: Unknown option &#39;$1&#39;&#34;
        exit 1
        ;;

      *)
        # We&#39;ve hit a non-option argument; stop parsing options
        break
        ;;
    esac
  done
}

startup() {
  echo
  echo &#39;  ______ _           _   _      &#39;
  echo &#39; |  ____| |         | | (_)     &#39;
  echo &#39; | |__  | | __ _ ___| |_ _  ___ &#39;
  echo &#39; |  __| | |/ _` / __| __| |/ __|&#39;
  echo &#39; | |____| | (_| \__ \ |_| | (__ &#39;
  echo &#39; |______|_|\__,_|___/\__|_|\___|&#39;
  echo &#39;-------------------------------------------------&#39;
  echo &#39;ðŸš€ Run Elasticsearch and Kibana for local testing&#39;
  echo &#39;-------------------------------------------------&#39;
  echo 
  echo &#39;â„¹ï¸  Do not use this script in a production environment&#39;
  echo

  # Version
  version=&#34;0.10.0&#34;

  # Folder name for the installation
  installation_folder=&#34;${ES_LOCAL_DIR:-elastic-start-local}&#34;
  # API key name for Elasticsearch
  api_key_name=&#34;elastic-start-local&#34;
  # Name of the error log
  error_log=&#34;error-start-local.log&#34;
  # Minimum version for docker-compose
  min_docker_compose=&#34;1.29.0&#34;
  # Elasticsearch container name
  elasticsearch_container_name=&#34;es-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}&#34;
  # Kibana container name
  kibana_container_name=&#34;kibana-local-dev${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}&#34;
  # Kibana settings container name
  kibana_settings_container_name=&#34;kibana-local-settings${ES_LOCAL_DIR:+-${ES_LOCAL_DIR}}&#34;
  # Minimum disk space required for docker images + services (in GB)
  min_disk_space_required=5
}

# Check for ARM64 architecture
is_arm64() {
  arch=&#34;$(uname -m)&#34;
  if [ &#34;$arch&#34; = &#34;arm64&#34; ] || [ &#34;$arch&#34; = &#34;aarch64&#34; ]; then
    return 0 # Return 0 (true)
  else
    return 1 # Return 1 (false)
  fi
}

# Alternative to sort -V, which is not available in BSD-based systems (e.g., macOS)
version_sort() {
  awk -F&#39;.&#39; &#39;
  {
      printf(&#34;%d %d %d %s\n&#34;, $1, $2, $3, $0)
  }&#39; | sort -n -k1,1 -k2,2 -k3,3 | awk &#39;{print $4}&#39;
}

# Function to check if the format is a valid semantic version (major.minor.patch)
is_valid_version() {
  echo &#34;$1&#34; | grep -E -q &#39;^[0-9]+\.[0-9]+\.[0-9]+$&#39;
}

# Get the latest stable version of Elasticsearch
# Note: It removes all the beta or candidate releases from the list
# but includes the GA releases (e.g. new major)
get_latest_version() {
  versions=&#34;$(curl -s &#34;https://artifacts.elastic.co/releases/stack.json&#34;)&#34;
  latest_version=$(echo &#34;$versions&#34; | awk -F&#39;&#34;&#39; &#39;/&#34;version&#34;: *&#34;/ {print $4}&#39; | grep -E &#39;^[0-9]+\.[0-9]+\.[0-9]+( GA)?$&#39; | version_sort | tail -n 1)
  # Remove the GA prefix from the version, if present
  latest_version=$(echo &#34;$latest_version&#34; | awk &#39;{ gsub(/ GA$/, &#34;&#34;, $0); print }&#39;)

  # Check if the latest version is empty
  if [ -z &#34;$latest_version&#34; ]; then
    echo &#34;Error: the latest Elasticsearch version is empty&#34;
    exit 1
  fi
  # Check if the latest version is valid
  if ! is_valid_version &#34;$latest_version&#34;; then
    echo &#34;Error: {$latest_version} is not a valid Elasticsearch stable version&#34;
    exit 1
  fi

  echo &#34;$latest_version&#34;
}

# Detect if running on LXC container
detect_lxc() {
    # Check /proc/1/environ for LXC container identifier
    if grep -qa &#34;container=lxc&#34; /proc/1/environ 2&gt;/dev/null; then
      return 0
    fi
    # Check /proc/self/cgroup for LXC references
    if grep -q &#34;lxc&#34; /proc/self/cgroup 2&gt;/dev/null; then
      return 0
    fi
    # Check for LXC in /sys/fs/cgroup
    if grep -q &#34;lxc&#34; /sys/fs/cgroup/* 2&gt;/dev/null; then  
      return 0
    fi
    # Use systemd-detect-virt if available
    if command -v systemd-detect-virt &gt;/dev/null 2&gt;&amp;1; then
      if [ &#34;$(systemd-detect-virt)&#34; = &#34;lxc&#34; ]; then
        return 0
      fi
    fi
    return 1
}

# Get linux distribution
get_os_info() {
  if [ -f /etc/os-release ]; then
      # Most modern Linux distributions have this file
      . /etc/os-release
      echo &#34;Distribution: $NAME&#34;
      echo &#34;Version: $VERSION&#34;
  elif [ -f /etc/lsb-release ]; then
      # For older distributions using LSB (Linux Standard Base)
      . /etc/lsb-release
      echo &#34;Distribution: $DISTRIB_ID&#34;
      echo &#34;Version: $DISTRIB_RELEASE&#34;
  elif [ -f /etc/debian_version ]; then
      # For Debian-based distributions without os-release or lsb-release
      echo &#34;Distribution: Debian&#34;
      echo &#34;Version: $(cat /etc/debian_version)&#34;
  elif [ -f /etc/redhat-release ]; then
      # For Red Hat-based distributions
      echo &#34;Distribution: $(cat /etc/redhat-release)&#34;
  elif [ -n &#34;${OSTYPE+x}&#34; ]; then
    if [ &#34;${OSTYPE#darwin}&#34; != &#34;$OSTYPE&#34; ]; then
        # macOS detection
        echo &#34;Distribution: macOS&#34;
        echo &#34;Version: $(sw_vers -productVersion)&#34;
    elif [ &#34;$OSTYPE&#34; = &#34;cygwin&#34; ] || [ &#34;$OSTYPE&#34; = &#34;msys&#34; ] || [ &#34;$OSTYPE&#34; = &#34;win32&#34; ]; then
        # Windows detection in environments like Git Bash, Cygwin, or MinGW
        echo &#34;Distribution: Windows&#34;
        echo &#34;Version: $(cmd.exe /c ver | tr -d &#39;\r&#39;)&#34;
    elif [ &#34;$OSTYPE&#34; = &#34;linux-gnu&#34; ] &amp;&amp; uname -r | grep -q &#34;Microsoft&#34;; then
        # Windows Subsystem for Linux (WSL) detection
        echo &#34;Distribution: Windows (WSL)&#34;
        echo &#34;Version: $(uname -r)&#34;
    fi
  else
      echo &#34;Unknown operating system&#34;
  fi
  if [ -f /proc/version ]; then
    # Check if running on WSL2 or WSL1 for Microsoft
    if grep -q &#34;WSL2&#34; /proc/version; then
      echo &#34;Running on WSL2&#34;
    elif grep -q &#34;microsoft&#34; /proc/version; then
      echo &#34;Running on WSL1&#34;
    fi
  fi
}

# Check if a command exists
available() { command -v &#34;$1&#34; &gt;/dev/null; }

# Revert the status, removing containers, volumes, network and folder
cleanup() {
  if [ -d &#34;./../$folder_to_clean&#34; ]; then
    if [ -f &#34;docker-compose.yml&#34; ]; then
      $docker_clean &gt;/dev/null 2&gt;&amp;1
      $docker_remove_volumes &gt;/dev/null 2&gt;&amp;1
    fi
    cd ..
    rm -rf &#34;${folder_to_clean}&#34;
  fi
}

# Generate the error log
# parameter 1: error message
# parameter 2: the container names to retrieve, separated by comma
generate_error_log() {
  msg=&#34;$1&#34;
  docker_services=&#34;$2&#34;
  error_file=&#34;$error_log&#34;
  if [ -d &#34;./../$folder_to_clean&#34; ]; then
    error_file=&#34;./../$error_log&#34;
  fi
  if [ -n &#34;${msg}&#34; ]; then
    echo &#34;${msg}&#34; &gt; &#34;$error_file&#34;
  fi
  { 
    echo &#34;Start-local version: ${version}&#34;
    echo &#34;Docker engine: $(docker --version)&#34;
    echo &#34;Docker compose: ${docker_version}&#34;
    get_os_info
  } &gt;&gt; &#34;$error_file&#34; 
  for service in $docker_services; do
    echo &#34;-- Logs of service ${service}:&#34; &gt;&gt; &#34;$error_file&#34;
    docker logs &#34;${service}&#34; &gt;&gt; &#34;$error_file&#34; 2&gt; /dev/null
  done
  echo &#34;An error log has been generated in ${error_log} file.&#34;
  echo &#34;If you need assistance, open an issue at https://github.com/elastic/start-local/issues&#34;
}

# Compare versions
# parameter 1: version to compare
# parameter 2: version to compare
compare_versions() {
  v1=$1
  v2=$2

  original_ifs=&#34;$IFS&#34;
  IFS=&#39;.&#39;
  # shellcheck disable=SC2086
  set -- $v1; v1_major=${1:-0}; v1_minor=${2:-0}; v1_patch=${3:-0}
  IFS=&#39;.&#39;
  # shellcheck disable=SC2086
  set -- $v2; v2_major=${1:-0}; v2_minor=${2:-0}; v2_patch=${3:-0}
  IFS=&#34;$original_ifs&#34;

  [ &#34;$v1_major&#34; -lt &#34;$v2_major&#34; ] &amp;&amp; echo &#34;lt&#34; &amp;&amp; return 0
  [ &#34;$v1_major&#34; -gt &#34;$v2_major&#34; ] &amp;&amp; echo &#34;gt&#34; &amp;&amp; return 0

  [ &#34;$v1_minor&#34; -lt &#34;$v2_minor&#34; ] &amp;&amp; echo &#34;lt&#34; &amp;&amp; return 0
  [ &#34;$v1_minor&#34; -gt &#34;$v2_minor&#34; ] &amp;&amp; echo &#34;gt&#34; &amp;&amp; return 0

  [ &#34;$v1_patch&#34; -lt &#34;$v2_patch&#34; ] &amp;&amp; echo &#34;lt&#34; &amp;&amp; return 0
  [ &#34;$v1_patch&#34; -gt &#34;$v2_patch&#34; ] &amp;&amp; echo &#34;gt&#34; &amp;&amp; return 0

  echo &#34;eq&#34;
}

# Wait for availability of Kibana
# parameter: timeout in seconds
wait_for_kibana() {
  timeout=&#34;${1:-60}&#34;
  echo &#34;- Waiting for Kibana to be ready&#34;
  echo
  start_time=&#34;$(date +%s)&#34;
  until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do
    elapsed_time=&#34;$(($(date +%s) - start_time))&#34;
    if [ &#34;$elapsed_time&#34; -ge &#34;$timeout&#34; ]; then
      error_msg=&#34;Error: Kibana timeout of ${timeout} sec&#34;
      echo &#34;$error_msg&#34;
      generate_error_log &#34;${error_msg}&#34; &#34;${elasticsearch_container_name} ${kibana_container_name} kibana-settings&#34;
      cleanup
      exit 1
    fi
    sleep 2
  done
}

# Generates a random password with letters and numbers
# parameter: size of the password (default is 8 characters)
random_password() {
  LENGTH=&#34;${1:-8}&#34;
  LC_ALL=C tr -dc &#39;A-Za-z0-9&#39; &lt; /dev/urandom | head -c &#34;${LENGTH}&#34;
}

# Create an API key for Elasticsearch
# parameter 1: the Elasticsearch password
# parameter 2: name of the API key to generate
create_api_key() {
  es_password=$1
  name=$2
  response=&#34;$(curl -s -u &#34;elastic:${es_password}&#34; -X POST http://localhost:9200/_security/api_key -d &#34;{\&#34;name\&#34;: \&#34;${name}\&#34;}&#34; -H &#34;Content-Type: application/json&#34;)&#34;
  if [ -z &#34;$response&#34; ]; then
    echo &#34;&#34;
  else
    api_key=&#34;$(echo &#34;$response&#34; | grep -Eo &#39;&#34;encoded&#34;:&#34;[A-Za-z0-9+/=]+&#39; | grep -Eo &#39;[A-Za-z0-9+/=]+&#39; | tail -n 1)&#34;
    echo &#34;$api_key&#34;
  fi
}

# Check if a container is runnning
# parameter: the name of the container
check_container_running() {
  container_name=$1
  containers=&#34;$(docker ps --format &#39;{{.Names}}&#39;)&#34;
  if echo &#34;$containers&#34; | grep -q &#34;^${container_name}$&#34;; then
    echo &#34;The docker container &#39;$container_name&#39; is already running!&#34;
    echo &#34;You can have only one running at time.&#34;
    echo &#34;To stop the container run the following command:&#34;
    echo
    echo &#34;docker stop $container_name&#34;
    exit 1
  fi
}

# Check the available disk space in GB
# parameter: required size in GB
check_disk_space_gb() {
  required=$1
  available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024))
  if [ &#34;$available_gb&#34; -lt &#34;$required&#34; ]; then
    echo &#34;Error: only ${available_gb} GB of disk space available; ${required} GB required for the installation&#34;
    exit 1
  fi
}

check_requirements() {
  # Check the requirements
  check_disk_space_gb ${min_disk_space_required}
  if ! available &#34;curl&#34;; then
    echo &#34;Error: curl command is required&#34;
    echo &#34;You can install it from https://curl.se/download.html.&#34;
    exit 1
  fi
  if ! available &#34;grep&#34;; then
    echo &#34;Error: grep command is required&#34;
    echo &#34;You can install it from https://www.gnu.org/software/grep/.&#34;
    exit 1
  fi
  need_wait_for_kibana=true
  # Check for &#34;docker compose&#34; or &#34;docker-compose&#34;
  set +e
  if ! docker compose &gt;/dev/null 2&gt;&amp;1; then
    if ! available &#34;docker-compose&#34;; then
      if ! available &#34;docker&#34;; then
        echo &#34;Error: docker command is required&#34;
        echo &#34;You can install it from https://docs.docker.com/engine/install/.&#34;
        exit 1
      fi
      echo &#34;Error: docker compose is required&#34;
      echo &#34;You can install it from https://docs.docker.com/compose/install/&#34;
      exit 1
    fi
    docker=&#34;docker-compose up -d&#34;
    docker_stop=&#34;docker-compose stop&#34;
    docker_clean=&#34;docker-compose rm -fsv&#34;
    docker_remove_volumes=&#34;docker-compose down -v&#34;
    docker_version=$(docker-compose --version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;)
    if [ &#34;$(compare_versions &#34;$docker_version&#34; &#34;$min_docker_compose&#34;)&#34; = &#34;lt&#34; ]; then
      echo &#34;Unfortunately we don&#39;t support docker compose ${docker_version}. The minimum required version is $min_docker_compose.&#34;
      echo &#34;You can migrate you docker compose from https://docs.docker.com/compose/migrate/&#34;
      cleanup
      exit 1
    fi 
  else
    docker_stop=&#34;docker compose stop&#34;
    docker_clean=&#34;docker compose rm -fsv&#34;
    docker_remove_volumes=&#34;docker compose down -v&#34;
    docker_version=$(docker compose version | head -n 1 | grep -Eo &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;)
    # --wait option has been introduced in 2.1.1+
    if [ &#34;$(compare_versions &#34;$docker_version&#34; &#34;2.1.0&#34;)&#34; = &#34;gt&#34; ]; then
      docker=&#34;docker compose up --wait&#34;
      need_wait_for_kibana=false
    else
      docker=&#34;docker compose up -d&#34;
    fi
  fi
  set -e
}

check_installation_folder() {
  # Check if $installation_folder exists
  folder=$installation_folder
  if [ -d &#34;$folder&#34; ]; then
    if [ -n &#34;$(ls -A &#34;$folder&#34;)&#34; ]; then
      echo &#34;It seems you have already a start-local installation in &#39;${folder}&#39;.&#34;
      if [ -f &#34;$folder/uninstall.sh&#34; ]; then
        echo &#34;I cannot proceed unless you uninstall it, using the following command:&#34;
        echo &#34;cd $folder &amp;&amp; ./uninstall.sh&#34;
      else
        echo &#34;I did not find the uninstall.sh file, you need to proceed manually.&#34;
        if [ -f &#34;$folder/docker-compose.yml&#34; ] &amp;&amp; [ -f &#34;$folder/.env&#34; ]; then
          echo &#34;Execute the following commands:&#34;
          echo &#34;cd $folder&#34;
          echo &#34;$docker_clean&#34;
          echo &#34;$docker_remove_volumes&#34;
          echo &#34;cd ..&#34;
          echo &#34;rm -rf $folder&#34;
        fi
      fi
      exit 1
    fi
  fi
}

check_docker_services() {
  # Check for docker containers running
  check_container_running &#34;$elasticsearch_container_name&#34;
  check_container_running &#34;$kibana_container_name&#34;
  check_container_running &#34;$kibana_settings_container_name&#34;
}

create_installation_folder() {
  # If $folder already exists, it is empty, see above
  if [ ! -d &#34;$folder&#34; ]; then 
    mkdir &#34;$folder&#34;
  fi
  cd &#34;$folder&#34;
  folder_to_clean=$folder
}

generate_passwords() {
  # Generate random passwords
  es_password=&#34;${ES_LOCAL_PASSWORD:-$(random_password)}&#34;
  if  [ -z &#34;${esonly:-}&#34; ]; then
    kibana_password=&#34;$(random_password)&#34;
    kibana_encryption_key=&#34;$(random_password 32)&#34;
  fi
}

choose_es_version() {
  if [ -z &#34;${es_version:-}&#34; ]; then
    # Get the latest Elasticsearch version
    es_version=&#34;$(get_latest_version)&#34;
  fi
  # Fix for ARM64: add suffix &#34;-arm64&#34;
  if is_arm64 &amp;&amp; [ &#34;${es_version##*-arm64}&#34; = &#34;$es_version&#34; ]; then
    es_version=&#34;${es_version}-arm64&#34;
  fi
}

create_env_file() {
  # Create the .env file
  cat &gt; .env &lt;&lt;- EOM
START_LOCAL_VERSION=$version
ES_LOCAL_VERSION=$es_version
ES_LOCAL_CONTAINER_NAME=$elasticsearch_container_name
ES_LOCAL_PASSWORD=$es_password
ES_LOCAL_PORT=9200
ES_LOCAL_URL=http://localhost:\${ES_LOCAL_PORT}
ES_LOCAL_HEAP_INIT=128m
ES_LOCAL_HEAP_MAX=2g
ES_LOCAL_DISK_SPACE_REQUIRED=1gb
EOM

  if  [ -z &#34;${esonly:-}&#34; ]; then
    cat &gt;&gt; .env &lt;&lt;- EOM
KIBANA_LOCAL_CONTAINER_NAME=$kibana_container_name
KIBANA_LOCAL_SETTINGS_CONTAINER_NAME=$kibana_settings_container_name
KIBANA_LOCAL_PORT=5601
KIBANA_LOCAL_PASSWORD=$kibana_password
KIBANA_ENCRYPTION_KEY=$kibana_encryption_key
EOM
  fi
}

# Create the start script (start.sh)
# including the license update if trial expired
create_start_file() {
  today=$(date +%s)
  expire=$((today + 3600*24*30))

  cat &gt; start.sh &lt;&lt;-&#39;EOM&#39;
#!/bin/sh
# Start script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR=&#34;$(cd &#34;$(dirname &#34;$0&#34;)&#34; &amp;&amp; pwd)&#34;
cd &#34;${SCRIPT_DIR}&#34;
today=$(date +%s)
. ./.env
# Check disk space
available_gb=$(($(df -k / | awk &#39;NR==2 {print $4}&#39;) / 1024 / 1024))
required=$(echo &#34;${ES_LOCAL_DISK_SPACE_REQUIRED}&#34; | grep -Eo &#39;[0-9]+&#39;)
if [ &#34;$available_gb&#34; -lt &#34;$required&#34; ]; then
  echo &#34;----------------------------------------------------------------------------&#34;
  echo &#34;WARNING: Disk space is below the ${required} GB limit. Elasticsearch will be&#34;
  echo &#34;executed in read-only mode. Please free up disk space to resolve this issue.&#34;
  echo &#34;----------------------------------------------------------------------------&#34;
  echo &#34;Press ENTER to confirm.&#34;
  # shellcheck disable=SC2034
  read -r line
fi
EOM
  if [ &#34;$need_wait_for_kibana&#34; = true ]; then
    cat &gt;&gt; start.sh &lt;&lt;-&#39;EOM&#39;
wait_for_kibana() {
  _timeout=&#34;${1:-60}&#34;
  echo &#34;- Waiting for Kibana to be ready&#34;
  echo
  _start_time=&#34;$(date +%s)&#34;
  until curl -s -I http://localhost:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;; do
    elapsed_time=&#34;$(($(date +%s) - _start_time))&#34;
    if [ &#34;$elapsed_time&#34; -ge &#34;$_timeout&#34; ]; then
      echo &#34;Error: Kibana timeout of ${_timeout} sec&#34;
      exit 1
    fi
    sleep 2
  done
}

EOM
  fi

  cat &gt;&gt; start.sh &lt;&lt;- EOM
if [ -z &#34;\${ES_LOCAL_LICENSE:-}&#34; ] &amp;&amp; [ &#34;\$today&#34; -gt $expire ]; then
  echo &#34;---------------------------------------------------------------------&#34;
  echo &#34;The one-month trial period has expired. You can continue using the&#34;
  echo &#34;Free and open Basic license or request to extend the trial for&#34;
  echo &#34;another 30 days using this form:&#34;
  echo &#34;https://www.elastic.co/trialextension&#34;
  echo &#34;---------------------------------------------------------------------&#34;
  echo &#34;For more info about the license: https://www.elastic.co/subscriptions&#34;
  echo
  echo &#34;Updating the license...&#34;
  $docker elasticsearch &gt;/dev/null 2&gt;&amp;1
  result=\$(curl -s -X POST &#34;\${ES_LOCAL_URL}/_license/start_basic?acknowledge=true&#34; -H &#34;Authorization: ApiKey \${ES_LOCAL_API_KEY}&#34; -o /dev/null -w &#39;%{http_code}\n&#39;)
  if [ &#34;\$result&#34; = &#34;200&#34; ]; then
    echo &#34;âœ… Basic license successfully installed&#34;
    echo &#34;ES_LOCAL_LICENSE=basic&#34; &gt;&gt; .env
  else 
    echo &#34;Error: I cannot update the license&#34;
    result=\$(curl -s -X GET &#34;\${ES_LOCAL_URL}&#34; -H &#34;Authorization: ApiKey \${ES_LOCAL_API_KEY}&#34; -o /dev/null -w &#39;%{http_code}\n&#39;)
    if [ &#34;\$result&#34; != &#34;200&#34; ]; then
      echo &#34;Elasticsearch is not running.&#34;
    fi
    exit 1
  fi
  echo
fi
$docker
EOM

  if [ &#34;$need_wait_for_kibana&#34; = true ]; then
    cat &gt;&gt; start.sh &lt;&lt;-&#39;EOM&#39;
wait_for_kibana 120
EOM
  fi
  chmod +x start.sh
}

# Create the stop script (stop.sh)
create_stop_file() {
  cat &gt; stop.sh &lt;&lt;-&#39;EOM&#39;
#!/bin/sh
# Stop script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR=&#34;$(cd &#34;$(dirname &#34;$0&#34;)&#34; &amp;&amp; pwd)&#34;
cd &#34;${SCRIPT_DIR}&#34;
EOM

  cat &gt;&gt; stop.sh &lt;&lt;- EOM
$docker_stop
EOM
  chmod +x stop.sh
}

# Create the uninstall script (uninstall.sh)
create_uninstall_file() {

  cat &gt; uninstall.sh &lt;&lt;-&#39;EOM&#39;
#!/bin/sh
# Uninstall script for start-local
# More information: https://github.com/elastic/start-local
set -eu

SCRIPT_DIR=&#34;$(cd &#34;$(dirname &#34;$0&#34;)&#34; &amp;&amp; pwd)&#34;

ask_confirmation() {
    echo &#34;Do you confirm? (yes/no)&#34;
    read -r answer
    case &#34;$answer&#34; in
        yes|y|Y|Yes|YES)
            return 0  # true
            ;;
        no|n|N|No|NO)
            return 1  # false
            ;;
        *)
            echo &#34;Please answer yes or no.&#34;
            ask_confirmation  # Ask again if the input is invalid
            ;;
    esac
}

cd &#34;${SCRIPT_DIR}&#34;
if [ ! -e &#34;docker-compose.yml&#34; ]; then
  echo &#34;Error: I cannot find the docker-compose.yml file&#34;
  echo &#34;I cannot uninstall start-local.&#34;
fi
if [ ! -e &#34;.env&#34; ]; then
  echo &#34;Error: I cannot find the .env file&#34;
  echo &#34;I cannot uninstall start-local.&#34;
fi
echo &#34;This script will uninstall start-local.&#34;
echo &#34;All data will be deleted and cannot be recovered.&#34;
if ask_confirmation; then
EOM

  cat &gt;&gt; uninstall.sh &lt;&lt;- EOM
  $docker_clean
  $docker_remove_volumes
  rm docker-compose.yml .env uninstall.sh start.sh stop.sh config/telemetry.yml
  if [ -z &#34;\$(ls -A config)&#34; ]; then
    rm -d config
  fi
  echo
  echo &#34;Do you want to remove the following Docker images?&#34;
  echo &#34;- docker.elastic.co/elasticsearch/elasticsearch:${es_version}&#34;
EOM

  if  [ -z &#34;${esonly:-}&#34; ]; then
    cat &gt;&gt; uninstall.sh &lt;&lt;- EOM
  echo &#34;- docker.elastic.co/kibana/kibana:${es_version}&#34;
EOM
  fi

  cat &gt;&gt; uninstall.sh &lt;&lt;- EOM
  if ask_confirmation; then
    if docker rmi &#34;docker.elastic.co/elasticsearch/elasticsearch:${es_version}&#34; &gt;/dev/null 2&gt;&amp;1; then
      echo &#34;Image docker.elastic.co/elasticsearch/elasticsearch:${es_version} removed successfully&#34;
    else
      echo &#34;Failed to remove image docker.elastic.co/elasticsearch/elasticsearch:${es_version}. It might be in use.&#34;
    fi
EOM

  if  [ -z &#34;${esonly:-}&#34; ]; then
    cat &gt;&gt; uninstall.sh &lt;&lt;- EOM
    if docker rmi docker.elastic.co/kibana/kibana:${es_version} &gt;/dev/null 2&gt;&amp;1; then
      echo &#34;Image docker.elastic.co/kibana/kibana:${es_version} removed successfully&#34;
    else
      echo &#34;Failed to remove image docker.elastic.co/kibana/kibana:${es_version}. It might be in use.&#34;
    fi
EOM
  fi

  cat &gt;&gt; uninstall.sh &lt;&lt;- EOM
  fi
  echo &#34;Start-local successfully removed&#34;
fi
EOM
  chmod +x uninstall.sh
}

create_docker_compose_file() {
  # Create the docker-compose-yml file
  cat &gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION}
    container_name: ${ES_LOCAL_CONTAINER_NAME}
    volumes:
      - dev-elasticsearch:/usr/share/elasticsearch/data
    ports:
      - 127.0.0.1:${ES_LOCAL_PORT}:9200
    environment:
      - discovery.type=single-node
      - ELASTIC_PASSWORD=${ES_LOCAL_PASSWORD}
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=false
      - xpack.license.self_generated.type=trial
      - xpack.ml.use_auto_machine_memory_percent=true
      - ES_JAVA_OPTS=-Xms${ES_LOCAL_HEAP_INIT} -Xmx${ES_LOCAL_HEAP_MAX}
      - cluster.routing.allocation.disk.watermark.low=${ES_LOCAL_DISK_SPACE_REQUIRED}
      - cluster.routing.allocation.disk.watermark.high=${ES_LOCAL_DISK_SPACE_REQUIRED}
      - cluster.routing.allocation.disk.watermark.flood_stage=${ES_LOCAL_DISK_SPACE_REQUIRED}
EOM
  
  # Fix for JDK AArch64 issue, see https://bugs.openjdk.org/browse/JDK-8345296
  if is_arm64; then
  cat &gt;&gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
      - &#34;_JAVA_OPTIONS=-XX:UseSVE=0&#34;
EOM
  fi

  # Fix for OCI issue on LXC, see https://github.com/elastic/start-local/issues/27
  if ! detect_lxc; then
  cat &gt;&gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
    ulimits:
      memlock:
        soft: -1
        hard: -1
EOM
  fi

  cat &gt;&gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
    healthcheck:
      test:
        [
          &#34;CMD-SHELL&#34;,
          &#34;curl --output /dev/null --silent --head --fail -u elastic:${ES_LOCAL_PASSWORD} http://elasticsearch:9200&#34;,
        ]
      interval: 10s
      timeout: 10s
      retries: 30

EOM

if  [ -z &#34;${esonly:-}&#34; ]; then
  cat &gt;&gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
  kibana_settings:
    depends_on:
      elasticsearch:
        condition: service_healthy
    image: docker.elastic.co/elasticsearch/elasticsearch:${ES_LOCAL_VERSION}
    container_name: ${KIBANA_LOCAL_SETTINGS_CONTAINER_NAME}
    restart: &#39;no&#39;
    command: &gt;
      bash -c &#39;
        echo &#34;Setup the kibana_system password&#34;;
        start_time=$$(date +%s);
        timeout=60;
        until curl -s -u &#34;elastic:${ES_LOCAL_PASSWORD}&#34; -X POST http://elasticsearch:9200/_security/user/kibana_system/_password -d &#34;{\&#34;password\&#34;:\&#34;${KIBANA_LOCAL_PASSWORD}\&#34;}&#34; -H &#34;Content-Type: application/json&#34; | grep -q &#34;^{}&#34;; do
          if [ $$(($$(date +%s) - $$start_time)) -ge $$timeout ]; then
            echo &#34;Error: Elasticsearch timeout&#34;;
            exit 1;
          fi;
          sleep 2;
        done;
      &#39;

  kibana:
    depends_on:
      kibana_settings:
        condition: service_completed_successfully
    image: docker.elastic.co/kibana/kibana:${ES_LOCAL_VERSION}
    container_name: ${KIBANA_LOCAL_CONTAINER_NAME}
    volumes:
      - dev-kibana:/usr/share/kibana/data
      - ./config/telemetry.yml:/usr/share/kibana/config/telemetry.yml
    ports:
      - 127.0.0.1:${KIBANA_LOCAL_PORT}:5601
    environment:
      - SERVER_NAME=kibana
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_PASSWORD=${KIBANA_LOCAL_PASSWORD}
      - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${KIBANA_ENCRYPTION_KEY}
      - ELASTICSEARCH_PUBLICBASEURL=http://localhost:${ES_LOCAL_PORT}
    healthcheck:
      test:
        [
          &#34;CMD-SHELL&#34;,
          &#34;curl -s -I http://kibana:5601 | grep -q &#39;HTTP/1.1 302 Found&#39;&#34;,
        ]
      interval: 10s
      timeout: 10s
      retries: 30

EOM
fi

  cat &gt;&gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
volumes:
  dev-elasticsearch:
EOM

if  [ -z &#34;${esonly:-}&#34; ]; then
  cat &gt;&gt; docker-compose.yml &lt;&lt;-&#39;EOM&#39;
  dev-kibana:
EOM
fi

create_kibana_config
}

create_kibana_config() {
  if [ ! -d &#34;config&#34; ]; then
    mkdir config
  fi
  # Create telemetry
  cat &gt; config/telemetry.yml &lt;&lt;- EOM
start-local:
  version: ${version}
EOM
}

print_steps() {
  if  [ -z &#34;${esonly:-}&#34; ]; then
    echo &#34;âŒ›ï¸ Setting up Elasticsearch and Kibana v${es_version}...&#34;
  else
    echo &#34;âŒ›ï¸ Setting up Elasticsearch v${es_version}...&#34;
  fi
  echo
  echo &#34;- Generated random passwords&#34;
  echo &#34;- Created the ${folder} folder containing the files:&#34;
  echo &#34;  - .env, with settings&#34;
  echo &#34;  - docker-compose.yml, for Docker services&#34;
  echo &#34;  - start/stop/uninstall commands&#34;
}

running_docker_compose() {
  # Execute docker compose
  echo &#34;- Running ${docker}&#34;
  echo
  set +e
  if ! $docker; then
    error_msg=&#34;Error: ${docker} command failed!&#34;
    echo &#34;$error_msg&#34;
    if  [ -z &#34;${esonly:-}&#34; ]; then
      generate_error_log &#34;${error_msg}&#34; &#34;${elasticsearch_container_name} ${kibana_container_name} kibana_settings&#34;
    else
      generate_error_log &#34;${error_msg}&#34; &#34;${elasticsearch_container_name}&#34;
    fi
    cleanup
    exit 1
  fi
  set -e
}

api_key() {
  # Create an API key for Elasticsearch
  api_key=$(create_api_key &#34;$es_password&#34; &#34;$api_key_name&#34;)
  if [ -n &#34;$api_key&#34; ]; then
    echo &#34;ES_LOCAL_API_KEY=${api_key}&#34; &gt;&gt; .env
  fi
}

kibana_wait() {
  if [ &#34;$need_wait_for_kibana&#34; = true ]; then
    wait_for_kibana 120
  fi
}

success() {
  echo
  if  [ -z &#34;${esonly:-}&#34; ]; then
    echo &#34;ðŸŽ‰ Congrats, Elasticsearch and Kibana are installed and running in Docker!&#34;
    echo
    echo &#34;ðŸŒ Open your browser at http://localhost:5601&#34;
    echo
    echo &#34;   Username: elastic&#34;
    echo &#34;   Password: ${es_password}&#34;
    echo
  else
    echo &#34;ðŸŽ‰ Congrats, Elasticsearch is installed and running in Docker!&#34;
  fi
  
  echo &#34;ðŸ”Œ Elasticsearch API endpoint: http://localhost:9200&#34;
  if [ -n &#34;$api_key&#34; ]; then
    echo &#34;ðŸ”‘ API key: $api_key&#34;
    echo
  else
    echo &#34;ðŸ”‘ Use basic auth or create an API key&#34;
    echo &#34;https://www.elastic.co/guide/en/kibana/current/api-keys.html&#34;
    echo
  fi
  echo
  echo &#34;Learn more at https://github.com/elastic/start-local&#34;

  echo
}

main() {
  parse_args &#34;$@&#34;
  startup
  check_requirements
  check_installation_folder
  check_docker_services
  create_installation_folder
  generate_passwords
  choose_es_version
  create_start_file
  create_stop_file
  create_uninstall_file
  create_env_file
  create_docker_compose_file
  print_steps
  running_docker_compose
  api_key
  kibana_wait
  success
}

ctrl_c() { 
  cleanup
  exit 1
}

# Trap ctrl-c
trap ctrl_c INT

# Execute the script
main &#34;$@&#34;
</code></pre></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://heyuuuu77.github.io/>heyuuuu77</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>