+++
date = '2025-02-14T09:32:22+08:00'
draft = false
title = '设计模式之美'
UseHugoToc = true
+++


#### 面向对象
面向对象编程是因为其具有丰富的特性(封装，抽象，继承，多态)，可以实现很多复杂的设计思路。

#### 设计原则
1.  SOLID原则 - SRP 单一职责原则
2.  SOLID原则 - OCP 开闭原则(对扩展开放，对修改关闭)
3.  SOLID原则 - LSP 里式替换原则: <br>
    **解释：** 所有引用基类的地方必须能透明地使用其子类的对象，也就是说，子类对象可以替换掉它们的基类对象，而程序的行为不会发生改变。<br>
    **示例：** 在一个游戏中有一个动物类，鸟类继承自动物类。如果在游戏中需要使用动物类的某个方法，那么使用鸟类对象来调用这个方法也应该能正常工作，并且不会出现意外的结果。

4.  SOLID原则 - ISP 接口隔离原则 <br>
    **解释：** 客户端不应该依赖它不需要的接口，即一个接口应该只包含客户端真正需要的方法，而不应该包含一些无关的方法。<br>
    **示例：** 在一个游戏开发中，有一个游戏控制器接口，其中只应该包含与游戏控制相关的方法，如开始游戏、暂停游戏等，而不应该包含与游戏画面渲染等无关的方法。

5.  SOLID原则 - DIP 依赖倒置原则 <br>
    **解释：** 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。即要针对接口编程，而不是针对实现编程。<br>
    **示例：** 在一个游戏开发中，游戏的业务逻辑模块是高层模块，游戏的底层渲染模块是低层模块。业务逻辑模块不应该直接依赖底层渲染模块的具体实现，而是应该依赖一个抽象的渲染接口，底层渲染模块实现这个接口。这样，当需要更换底层渲染引擎时，只需要更换实现渲染接口的类，而不需要修改业务逻辑模块的代码。

6.  DRY原则(Don't Repeat Yourself)、 KISS原则、 YAGNI原则(You Aren't Gonna Need It)、 LOD法则(Law Of Demete)

#### 设计模式
经典的23种设计模式，分为创建型，结构型，行为型。

1. 创建型: (5)
    **常用** 单例模式、工厂模式(工厂方法和抽象工厂)、建造者模式 (4)
    **不常用** 原型模式 (1)
    
    创建型模式主要解决对象的创建问题，封装复杂的创建过程，解偶对象的创建代码和使用代码。

2. 结构型: (7)
    **常用** 代理模式、 桥接模式、 装饰者模式、适配器模式 (4)
    **不常用** 门面模式、组合模式、享元模式 (3)



3. 行为型: (11)
    **常用** 观察者模式、模版模式、策略模式、责任链模式、迭代器模式、状态模式 (6)
    **不常用** 访问者模式、备忘录模式、命令模式、解释器模式、中介模式 (5)

#### 编程规范
目的是为了提高代码的可读性。

#### 代码重构
为了避免过度设计，程序初期不应该运用太复杂的设计模式，保留很多扩展性插槽。但是后期业务逻辑复杂度变高，就要不断的去重构，优化自身的代码。 
可以分成两部分，
大重构是整体结构，设计模式的替换之类的重构。小重构包括函数重命名，逻辑优化之类的小规模低层次的优化。

![示例图片](/images/design_pattern.jpg)

1. Abstract Factory: 抽象工厂。 提供一个创建一系列相关或相互依赖对象的接口。而无需指定它们具体的类。
2. Adapter: 适配器模式。将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
3. Bridge: 桥接模式。 将抽象部分和它的实现部分分离。使他们都可以独立的变化。
4. Builder: 建造者模式。将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。
5. Chain Of Responsibility: 责任链模式。 为解除请求的发送者和接收者之间的耦合。而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
6. Command: 命令模式。 将一个请求封装成一个对象。从而使你可以用不用的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
7. Composite: 组合模式。将对象组合成树形结构以表示"部分-整体"的层次结构。 Composite 使得客户对单个对象和复合对象的使用具有一致性。
8. Decorator: 装饰器模式。动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。
9. Facade: 外观模式。为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
10. Fatory Method: 工厂模式。 定义一个用于创建对象的接口。 让子类决定将哪一个类实例化。 Factory Method 使一个类的实例化延迟到其子类。 
11. Flyweight: 享元模式。运用共享技术有效地支持大量细粒度的对象。 
12. Interpreter: 解释器模式。给定一个语言，定义他的文法的一种表示，并给定一个解释器，该解释器使用该表示来解释语言中的句子。 
13. Iterator: 迭代器模式。提供一个方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 
14. Mediator: 用一个中介对象来封装一系列的对象交互。 中介者使各对象不需要显式地相互引用，从而使耦合松散， 而且可以独立地改变他们之间的交互。
15. Memento: 在不破坏封装行的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这有以后就可以将该对象恢复到保存的状态。
16. Observer: 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并自动刷新。
17. Prototype: 原型模式。用原型实例指定创建对象的种类，并且通过copy这个原型来创建新的对象。
18. Proxy: 代理模式。 为其他对象提供一个代理以控制对这个对象的访问。
19. Singleton: 单例模式。保证一个类仅有一个实例，并提供一个访问它的全局访问点。
20. State: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
21. Strategy: 策略模式。定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 
22. Template Method: 模版模式。 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 
23. Vistor: 观察者模式。 表示一个作用于某对象结构中的各元素操作。 它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 

创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎么交互和怎么分配职责进行描述。

![设计模式分类](/images/dp_category.jpg)

类模式处理类和子类之间的关系。 这些关系通过继承建立，是静态的，在编译时刻便确定下来了。

对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。


#### 多态
多态可以通过接口和继承的方式实现。对于动态语言，例如python，甚至都不需要继承。
因为python支持 duck-typing。如果两个毫不相干的类都实现了某个方法，就可以通过传入不同的类的实例，去实现多态。


#### 依赖注入(DI)、控制反转(IoC)
**控制反转** 是一种设计原则，用于解偶程序的依赖关系。传统的程序流程是由开发者直接控制，而IoC是将控制权交给容器或框架，由框架来管理对象的创建，依赖注入和生命周期。

IoC的核心思想是：
- 将控制权从程序代码中转移到外部容器或框架
- 依赖关系的管理由容器负责，而不是开发者手动管理

IoC最常见的实现方式就是*依赖注入(Dependency Injection)*

上面是比较官方的定义， 我的理解是为了不直接在代码中实例化一个类，而是把实例化过程放到程序外部，通过传参将对象传递到程序内部，从而实现解偶。


依赖注入的三种方式
- 构造函数注入
- Setter方法
- 接口注入


下面是一个基础的依赖注入的python示例：

```python
# 定义 UserRepository类，负责用户数据访问
class UserRepository:
    def get_user(self, user_id):
        return f"UserId {user_id} from database"

# UserService 类，依赖于 UserRepository
class UserService:
    def __init__(self, user_repository):
        self.user_repository = user_repository

    def get_user_info(self. user_id):
        self.user_repository.get_user(user_id)


# 使用
# 创建 UserRepository 实例
user_repository = UserRepository()

# 将 UserRepository 注入到 UserService 中
user_service = UserService(user_repository)

user_service.get_user_info(1)

```

实际项目中，不会直接这么使用，会用到IoC容器管理依赖，紧接上面的代码：
```python
# 定义一个容器
class Container:
    def __init__(self):
        self.dependencies = {}

    # 将依赖关系注册到依赖表中
    def register(self, name, dependency):
        self.dependencies[name] = dependency

    # 解码，从依赖表中获取依赖关系
    def resolve(self, name):
        self.dependencies.get(name)


# 使用IoC容器
container = Container()

# 注册依赖
container.register("user_repository", UserRepository())

# 解析依赖并创建UserService
user_service = UserService(container.resolve("user_repository"))

user_service.get_user_info(2)

```


#### 充血模型和贫血模型
传统的Web开发后端基本都是基于MVC三层框架，model数据层，跟View视图层，和业务逻辑Controller层，彼此拆分不同的类型。这种就是“贫血”模型。
是指将数据跟操作分离，破坏了面向对象的封装特性，属于典型的面向过程的的编码风格。


**“充血”模型:** 是将数据和对应的业务逻辑封装到同一个类中
**DDD开发模式:** Domain Driven Design,DDD。 领域驱动设计。 用来指导如何解偶业务系统，划分业务模块，以及定义业务领域模型及其交互。
因为微服务的兴起被大众熟知，用来指导服务划分。 




### 结构性
代理、桥接、装饰器、适配器 4种是比较常见的结构型设计模式。他们的代码结构非常相似。笼统来说，它们都可以称之为 Wrapper 模式。也就是通过 Wrapper 类二次封装原始类。

它们之间的主要区别是解决的问题、应用场景不同。

- 代理模式: 在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问。而非加强功能，这是它跟装饰器模式最大的不同。
- 桥接模式: 将接口部分和实现部分分离，从而让它们可以较为轻易、也相对独立的加以改变。
- 装饰器模式: 在不改变原始类的情况下，对原始类的功能进行增强，并且支持多个装饰器嵌套使用。
- 适配器模式: 是一种事后的补救策略。适配器提供跟原始类不同的接口。而代理模式、装饰器模式提供的都是跟原始类相同的接口。